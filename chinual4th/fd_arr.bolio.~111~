.c This file is part of the Lisp Machine Manual.  -*-Bolio-*-
.c Function Description: Array Functions

.chapter "Arrays"
.setq array section-page
.setq array-chapter chapter-number
.cindex array

	An 2array* is a Lisp object that consists of a group of cells,
each of which may contain an object.  The individual cells are
selected by numerical 2subscripts*.
'cindex "subscript"

	The 2dimensionality* of an array (or, the number of dimensions
which the array has) is the number of subscripts used to
refer to one of the elements of the array.  The dimensionality
may be any integer from one to seven, inclusively.
.c How about zero?

	The lowest value for any subscript is zero; the highest value
is a property of the array.  Each dimension has a size, which is
the lowest number which is too great to be used as a subscript.
For example, in a one-dimensional array of five elements, the size
of the one and only dimension is five, and the acceptable
values of the subscript are zero, one, two, three, and four.

	The most basic primitive functions for handling arrays are:
3make-array*, which is used for the creation of arrays, 3aref*,
which is used for examining the
contents of arrays, and 3aset*, which
is used for storing into arrays.

	An array is a regular Lisp object, and it is common for an
array to be the binding of a symbol, or the car or cdr of a cons,
or, in fact, an element of an array.  There are many functions,
described in this chapter, which take arrays as arguments and
perform useful operations on them.

Another way of handling arrays, inherited from Maclisp, is to treat them
as functions.  In this case each array has a name, which is a symbol
whose function definition is the array.  Zetalisp supports this
style by allowing an array to be 2applied* to arguments, as if it were
a function.  The arguments are treated as subscripts and the array is
referenced appropriately.  The 3store* special form (see (store-fun))
is also supported.  This kind of array referencing is considered to be
obsolete, and is slower than the usual kind.  It should not be used in
new programs.

.setq array-type page
.cindex types of arrays
	There are many types of arrays.  Some types of arrays can hold
Lisp objects of any type; the other types of arrays can only hold
fixnums or flonums.  The array types are known by a set of symbols whose names
begin with "3art-*" (for ARray Type).

.vindex art-q
	The most commonly used type is called 3art-q*.  An 3art-q*
array simply holds Lisp objects of any type.

.vindex art-q-list
.setq art-q-list-var page
	Similar to the 3art-q* type is the 3art-q-list*.  Like the
3art-q*, its elements may be any Lisp object.  The difference is that
the 3art-q-list* array "doubles" as a list; the function 3g-l-p*
will take an 3art-q-list* array and return a list whose
elements are those of the array, and whose actual substance is that of
the array.  If you 3rplaca* elements of the list, the corresponding
element of the array will change, and if you store into the array, the
corresponding element of the list will change the same way.
An attempt to 3rplacd* the list will cause an error, since arrays
cannot implement that operation.

.vindex art-1b
.vindex art-2b
.vindex art-4b
.vindex art-8b
.vindex art-16b
	There is a set of types called 3art-1b, art-2b, art-4b, art-8b*, 
and 3art-16b*;
these names are short for "1 bit", "2 bits", and so on.  Each element
of an 3art-2n*b* array is a non-negative fixnum, and only the
least significant 2n* bits are remembered in the array; all of the others are discarded.  Thus 3art-1b* arrays store only 0 and 1, and
if you store a 5 into an 3art-2b* array and look at it
later, you will find a 1 rather than a 5.
	These arrays are used when it is known beforehand that the
fixnums which will be stored are non-negative and limited in size to a
certain number of bits.  Their advantage over the 3art-q* array is
that they occupy less storage, because more than one element of the
array is kept in a single machine word.  (For example, 32 elements
of an 3art-1b* array or 2 elements of an 3art-16b* array
will fit into one word).

.vindex art-32b
	There are also 3art-32b* arrays which have 32 bits per element.
Since fixnums only have 24 bits anyway, these are the same as 3art-q*
arrays except that they only hold fixnums.  They do not behave consistently
with the other "bit" array types, and generally they should not be used.

.vindex art-string
	Character strings are implemented by the 3art-string* array
type.  This type acts similarly to the 3art-8b*; its elements must be
fixnums, of which only the least significant eight bits are stored.
However, many important system functions, including 3read*,
3print*, and 3eval*, treat 3art-string* arrays very differently
from the other kinds of arrays.  These arrays are usually called
2string*s, and chapter (string-chapter) of this manual deals with functions
that manipulate them.

.vindex art-fat-string
	An 3art-fat-string* array is a character string with wider characters, containing
16 bits rather than 8 bits.  The extra bits are ignored by string operations,
such as comparison, on these strings; typically they are used to hold font
information.

.vindex art-half-fix
	An 3art-half-fix* array contains half-size fixnums.  Each element
of the array is a signed 16-bit integer; the range is from -32768 to 32767
inclusive.

.vindex art-float
	The 3art-float* array type is a special-purpose type whose
elements are flonums.  When storing into such an array the value (any
kind of number) will be converted to a flonum, using the 3float*
function (see (float-fun)).  The advantage of
storing flonums in an 3art-float* array rather than an 3art-q*
array is that the numbers in an 3art-float* array are not true Lisp
objects.  Instead the array remembers the numerical value, and when it
is 3aref*'ed creates a Lisp object (a flonum) to hold the value.
Because the system does special storage management for bignums and
flonums that are intermediate results, the use of 3art-float* arrays
can save a lot of work for the garbage-collector and hence greatly
increase performance.  An intermediate result is a Lisp object passed
as an argument, stored in a local variable, or returned as the value of
a function, but not stored into a global variable, a non-3art-float*
array, or list structure.  3art-float* arrays also provide a locality
of reference advantage over 3art-q* arrays containing flonums, since
the flonums are contained in the array rather than being separate objects
probably on different pages of memory.

.vindex art-fps-float
	The 3art-fps-float* array type is another special-purpose type
whose elements are flonums.  The internal format of this array is compatible
with the pdp11/VAX single-precision floating-point format.  The primary purpose
of this array type is to interface with the FPS array processor, which can
transfer data directly in and out of such an array.
	When storing into an 3art-fps-float* array any kind of number may
be stored.  It will be rounded off to the 24-bit precision of the pdp11.  If
the magnitude of the number is too large, the largest valid floating-point
number will be stored.  If the magnitude is too small, zero will be stored.
	When reading from an 3art-fps-float* array, a new flonum is created
containing the value, just as with an 3art-float* array.

.vindex art-stack-group-head
.vindex art-reg-pdl
.vindex art-special-pdl
	There are three types of arrays which exist only for the
implementation of 2stack groups*; these types are called
3art-stack-group-head, art-special-pdl*, and 3art-reg-pdl*.  Their elements
may be any Lisp object; their use is explained in the section on
stack groups (see (stack-group)).
'cindex "stack group"

.setq column-major section-page
Currently, multi-dimensional arrays are stored in column-major order
rather than row-major order as in Maclisp.   Row-major order means that
successive memory locations differ in the last subscript, while
column-major order means that successive memory locations differ in the
first subscript.  This has an effect on paging performance when using
large arrays; if you want to reference every element in a
multi-dimensional array and move linearly through memory to improve
locality of reference, you must vary the first subscript fastest rather
than the last.

.defvar array-types
The value of 3array-types* is a list of all of the array type symbols
such as 3art-q*, 3art-4b*, 3art-string* and so on.  The values
of these symbols are internal array type code numbers for the corresponding
type.
.end_defvar

.defun array-types array-type-code
Given an internal numeric array-type code, returns the symbolic name
of that type.
.end_defun

.defvar array-elements-per-q
3array-elements-per-q* is an association list (see (alist)) which
associates each array type symbol with the number of array elements
stored in one word, for an array of that type.  If the value is negative,
it is instead the number of words per array element, for arrays whose
elements are more than one word long.
.end_defvar

.defun array-elements-per-q array-type-code
Given the internal array-type code number, returns the number of array
elements stored in one word, for an array of that type.  If the value
is negative, it is instead the number of words per array element, for
arrays whose elements are more than one word long.
.end_defun

.defvar array-bits-per-element
The value of 3array-bits-per-element* is an association list (see (alist))
which associates each array type symbol with the number of
bits of unsigned number it can hold, or 3nil* if it can
hold Lisp objects.  This can be used to tell whether an array
can hold Lisp objects or not.
.end_defvar

.defun array-bits-per-element array-type-code
Given the internal array-type code numbers, returns the number of bits
per cell for unsigned numeric arrays, or 3nil* for a type of array
that can contain Lisp objects.
.end_defun

.defun array-element-size array
Given an array, returns the number of bits that fit in an element of
that array.  For arrays that can hold general Lisp objects, the result is
24., assuming you will be storing unsigned fixnums in the array.
.end_defun

.section "Extra Features of Arrays"
'cindex "array leader"
	Any array may have an 2array leader*.  An array leader is
like a one-dimensional 3art-q* array which is attached to the main
array.  So an array which has a leader acts like two arrays joined
together.  The leader can be stored into and examined by a special set
of functions, different from those used for the main array:
3array-leader* and 3store-array-leader*.  The leader is always
one-dimensional, and always can hold any kind of Lisp object,
regardless of the type or dimensionality of the main part of the array.

Very often the main part of an array will be a homogeneous set of objects,
while the leader will be used to remember a few associated non-homogeneous pieces of data.
In this case the leader is not used like an array; each slot is used
differently from the others.  Explicit numeric subscripts should not be
used for the leader elements of such an array; instead the leader should be described
by a 3defstruct* (see (defstruct-fun)).

	By convention, element 0 of the array leader of
an array is used to hold the number of elements in the array
that are "active" in some sense.  When the zeroth element is used
this way, it is called a 2fill pointer*.
'cindex "fill pointer"
'setq fill-pointer page
Many array-processing functions recognize the fill pointer.
For instance, if a string (an array of type 3art-string*) has
seven elements, but its fill pointer contains the value five, then only elements
zero through four of the string are considered to be "active"; the string's
printed representation will be five characters long, string-searching
functions will stop after the fifth element, etc.

	The system does not provide a way to turn off the fill-pointer
convention; any array that has a leader must reserve element 0 for the
fill pointer or avoid using many of the array functions.

	Leader element 1 is used in conjunction with the "named
structure" feature to associate a "data type" with the array; see
(named-structure).  Element 1 is only treated specially if the array
is flagged as a named structure.

'cindex "displaced array"
	The following explanation of 2displaced arrays*
is probably not of interest to a beginner; the section may
be passed over without losing the continuity of the manual.

	Normally, an array is represented as a small amount of header
information, followed by the contents of the array.  However, sometimes
it is desirable to have the header information removed from the actual
contents.  One such occasion is when the contents of the array must be
located in a special part of the Lisp Machine's address space, such as
the area used for the control of input/output devices, or the bitmap
memory which generates the TV image.  Displaced arrays are also used to
reference certain special system tables, which are at fixed addresses
so the microcode can access them easily.

	If you give 3make-array* a fixnum or a locative
as the value of the 3:displaced-to* option,
it will create a displaced array referring to that location of virtual memory
and its successors.
References to elements of the displaced array will access that part
of storage, and return the contents; the regular 3aref* and
3aset* functions are used.  If the array is one whose elements
are Lisp objects, caution should be used: if the region of address
space does not contain typed Lisp objects, the integrity of the storage
system and the garbage collector could be damaged.  If the array is one
whose elements are bytes (such as an 3art-4b* type), then there
is no problem.  It is important to know, in this case, that the elements
of such arrays are allocated from the right to the left within the 32-bit
words.

'cindex "indirect array"
.setq indirect-array page
	It is also possible to have an array whose contents, instead
of being located at a fixed place in virtual memory, are defined
to be those of another array.  Such an array is called an 2indirect array*,
and is created by giving 3make-array* an array as
the value of the 3:displaced-to* option.
The effects of this are simple if both arrays have the same type; the two
arrays share all elements.  An object stored in a certain element
of one can be retrieved from the corresponding element of the other.
This, by itself, is not very useful.  However, if the arrays have
different dimensionality, the manner of accessing the elements differs.
Thus, by creating a one-dimensional array of nine elements which was
indirected to a second, two-dimensional array of three elements by three,
then the elements could be accessed in either a one-dimensional or
a two-dimensional manner.  Weird effects can be produced if
the new array is of a different type than the old array; this is not
generally recommended.  Indirecting an 3art-2m*b* array to
an 3art-2n*b* array will do the "obvious" thing.  For instance,
if 2m* is 4 and 2n* is 1, each element of the first array
will contain four bits from the second array, in right-to-left order.

.cindex "index offset"
.setq index-offset page
	It is also possible to create an indirect array in such a way
that when an attempt is made to reference it or store into it, a
constant number is added to the subscript given.  This number is called
the 2index-offset*, and is specified at the time the indirect array
is created, by giving a fixnum to 3make-array*
as the value of the 3:displaced-index-offset* option.
Similarly, the length of the indirect array need not be the full length of
the array it indirects to; it can be smaller.
The 3nsubstring* function (see (nsubstring-fun)) creates such
arrays.  When using index offsets with multi-dimensional arrays, there
is only one index offset; it is added in to the "linearized" subscript
which is the result of multiplying each subscript by an appropriate
coefficient and adding them together.

.section "Basic Array Functions"

.defun make-array dimensions &rest options.
This is the primitive function for making arrays.  2dimensions*
should be a list of fixnums which are the dimensions of the array; the
length of the list will be the dimensionality of the array.  For
convenience when making a one-dimensional array, the single dimension
may be provided as a fixnum rather than a list of one fixnum.

2options* are alternating keywords and values.  The keywords may be
any of the following:
.table 3
.kitem :area
The value specifies in which area (see (area)) the list should be created.
It should be either an area number (a fixnum), or 3nil* to mean the
default area.

.kitem :type
The value should be a symbolic name of an array type; the most
common of these is 3art-q*, which is the default.  The elements of the array are
initialized according to the type:  if the array is of a type whose
elements may only be fixnums or flonums, then every element of the array will
initially be 30* or 30.0*; otherwise, every element will initially be
3nil*.  See the description of array types on (array-type).
The value of the option may also be the value of a symbol which is an array type name
(that is, an internal numeric array type code).
'cindex "array initialization"

.kitem :displaced-to
If this is not 3nil*, then the array will be a 2displaced* array.
If the value is a fixnum or a locative, 3make-array* will create a
regular displaced array which refers to the specified section of virtual
address space.
If the value is an array, 3make-array* will create
an indirect array (see (indirect-array)).
'cindex "displaced array"
'cindex "indirect array"

.kitem :leader-length
The value should be a fixnum.  The array will have a leader with that
many elements.  The elements of the leader will be initialized to 3nil*
unless the 3:leader-list* option is given (see below).

.kitem :leader-list
The value should be a list.  Call the number of elements in the list 2n*.
The first 2n* elements of the leader will be initialized from successive
elements of this list.  If the 3:leader-length* option is not specified,
then the length of the leader will be 2n*.  If the 3:leader-length*
option is given, and its value is greater than 2n*, then the 2n*th
and following leader elements will be initialized to 3nil*.  If its value
is less than 2n*, an error is signalled.  The leader elements are
filled in forward order; that is, the 3car* of the list will be stored
in leader element 30*, the 3cadr* in element 31*, and so on.

.kitem :displaced-index-offset
If this is present, the value of the 3:displaced-to* option should be an
array, and the value should be a non-negative fixnum; it is made to be the
index-offset of the created indirect array. (See (index-offset).)
'cindex "index offset"

.kitem :named-structure-symbol
If this is not 3nil*, it is a symbol to
be stored in the named-structure cell of the array.  The array
will be tagged as a named structure (see (named-structure).)  If
the array has a leader, then this symbol will be stored in leader element
31* regardless of the value of the 3:leader-list* option.  If the array
does not have a leader, then this symbol will be stored in array element zero.
.end_table

.lisp
.exdent 96 Examples:
1;; Create a one-dimensional array of five elements.*
(make-array 5)
1;; Create a two-dimensional array,*
1;; three by four, with four-bit elements.*
(make-array '(3 4) ':type 'art-4b)
1;; Create an array with a three-element leader.*
(make-array 5 ':leader-length 3)
1;; Create an array with a leader, providing*
1;; initial values for the leader elements.*
(setq a (make-array 100 ':type 'art-1b
			':leader-list '(t nil)))
(array-leader a 0) => t
(array-leader a 1) => nil
.end_lisp
.lisp
1;; Create a named-structure with five leader*
1;; elements, initializing some of them.*
(setq b (make-array 20 ':leader-length 5 
		       ':leader-list '(0 nil foo)
		       ':named-structure-symbol 'bar))
(array-leader b 0) => 0
(array-leader b 1) => bar
(array-leader b 2) => foo
(array-leader b 3) => nil
(array-leader b 4) => nil
'cindex "array leader"
.end_lisp

	3make-array* returns the newly-created array, and also
returns, as a second value, the number of words allocated in the process
of creating the array, i.e. the 3%structure-total-size* of the array.

When 3make-array* was originally implemented, it took its arguments
in the following fixed pattern:
.lisp
   (make-array 2area* 2type* 2dimensions*
               &optional 2displaced-to* 2leader*
			 2displaced-index-offset*
			 2named-structure-symbol*)
.end_lisp
2leader* was a combination of the 3:leader-length* and 3:leader-list*
options, and the list was in reverse order.
This obsolete form is still supported so that old programs will continue
to work, but the new keyword-argument form is preferred.
.end_defun

.defun aref array &rest subscripts
Returns the element of 2array* selected by the 2subscripts*.
The 2subscripts* must be fixnums and their number must match the
dimensionality of 2array*.
.end_defun

.defun ar-1 array i
.defun1 ar-2 array i j
.defun1 ar-3 array i j k
These are obsolete versions of 3aref* that only work for one, two, or three
dimensional arrays, respectively.  There is no reason ever to use them.
.end_defun

.defun aset x array &rest subscripts
Stores 2x* into the element of 2array* selected by the 2subscripts*.
The 2subscripts* must be fixnums and their number must match the
dimensionality of 2array*.  The returned value is 2x*.
.end_defun

.defun as-1 x array i
.defun1 as-2 x array i j
.defun1 as-3 x array i j k
These are obsolete versions of 3aset* that only work for one, two, or three
dimensional arrays, respectively.  There is no reason ever to use them.
.end_defun

.defun aloc array &rest subscripts
Returns a locative pointer to the element-cell of 2array* selected by
the 2subscripts*.  The 2subscripts* must be fixnums and their
number must match the dimensionality of 2array*.
See the explanation of locatives in (locative).
.end_defun

.defun ap-1 array i
.defun1 ap-2 array i j
.defun1 ap-3 array i j k
These are obsolete versions of 3aloc* that only work for one, two, or three
dimensional arrays, respectively.  There is no reason ever to use them.
.end_defun

The compiler turns 3aref* into 3ar-1*, 3ar-2*, etc. according
to the number of subscripts specified, turns 3aset* into 3as-1*,
3as-2*, etc., and turns 3aloc* into 3ap-1*, 3ap-2*, etc.
For arrays with more than 3 dimensions the compiler uses the slightly less
efficient form since the special routines only exist for 1, 2, and 3 dimensions.
There is no reason for any program to call 3ar-1*, 3as-1*, 3ar-2*, etc.
explicitly; they are documented because there used to be such a reason, and
many old programs use these functions.  New programs should use 3aref*,
3aset*, and 3aloc*.

A related function, provided only for Maclisp compatibility, is
3arraycall* ((arraycall-fun)).


.defun array-leader array i
2array* should be an array with a leader, and 2i* should be a
fixnum.  This returns the 2i*'th element of 2array*'s leader.
This is analogous to 3aref*.
.end_defun

.defun store-array-leader x array i
2array* should be an array with a leader, and 2i* should be a
fixnum.  2x* may be any object.  2x* is stored in the 2i*'th element
of 2array*'s leader.  3store-array-leader* returns 2x*.
This is analogous to 3aset*.
.end_defun

.defun ap-leader array i
2array* should be an array with a leader, and 2i* should be a
fixnum.  This returns a locative pointer to the 2i*'th element of
2array*'s leader.  See the explanation of locatives, (locative).
This is analogous to 3aloc*.
.end_defun


.section Getting Information About an Array

.defun array-type array
Returns the symbolic type of 2array*.
.lisp
.exdent 96 Example:
(setq a (make-array '(3 5)))
(array-type a) => art-q
.end_lisp
.end_defun

.defun array-length array
2array* may be any array.  This returns the total number
of elements in 2array*.  For a one-dimensional array,
this is one greater than the maximum allowable subscript.
(But if fill pointers are being used, you may want to use
3array-active-length*.)
.lisp
.exdent 96 Example:
(array-length (make-array 3)) => 3
(array-length (make-array '(3 5)))
		=> 17  1;octal, which is 15. decimal*
.end_lisp
.end_defun

.defun array-active-length array
If 2array* does not have a fill pointer, then this returns whatever
3(array-length 2array*)* would have.  If 2array* does have a
fill pointer, 3array-active-length* returns it.  See the general
explanation of the use of fill pointers, on (fill-pointer).
.end_defun

.defun array-#-dims array
Returns the dimensionality of 2array*.  Note that the name of the
function includes a "#", which must be slashified if you want to be
able to read your program in Maclisp.  (It doesn't need to be slashified
for the Zetalisp reader, which is smarter.)
.lisp
.exdent 96 Example:
(array-#-dims (make-array '(3 5))) => 2
.end_lisp
.end_defun

.defun array-dimension-n n array
2array* may be any kind of array, and 2n* should be a fixnum.
If 2n* is between 1 and the dimensionality of 2array*,
this returns the 2n*'th dimension of 2array*.  If 2n* is 30*,
this returns the length of the leader of 2array*; if 2array* has no
leader it returns 3nil*.  If 2n* is any other value, this
returns 3nil*.
.lisp
.exdent 96 Examples:
(setq a (make-array '(3 5) ':leader-length 7))
(array-dimension-n 1 a) => 3
(array-dimension-n 2 a) => 5
(array-dimension-n 3 a) => nil
(array-dimension-n 0 a) => 7
.end_lisp
.end_defun

.defun array-dimensions array
3array-dimensions* returns a list whose elements are the dimensions
of 2array*.
.lisp
.exdent 96 Example:
(setq a (make-array '(3 5)))
(array-dimensions a) => (3 5)
.end_lisp
Note: the list returned by 3(array-dimensions 2x*)* is
equal to the cdr of the list returned by 3(arraydims 2x*)*.
.end_defun

.defun arraydims array
2array* may be any array; it also may be a symbol whose
function cell contains an array, for Maclisp compatibility (see (maclisp-array)).
3arraydims* returns a list whose first element is the symbolic name of
the type of 2array*, and whose remaining elements are its dimensions.
.lisp
.exdent 96 Example:
(setq a (make-array '(3 5)))
(arraydims a) => (art-q 3 5)
.end_lisp
.end_defun

.defun array-in-bounds-p array &rest subscripts
This function checks whether 2subscripts* is a legal
set of subscripts for 2array*, and returns 3t* if they
are; otherwise it returns 3nil*.
.end_defun

.defun array-displaced-p array
2array* may be any kind of array.
This predicate returns 3t* if 2array* is any kind of displaced array
(including an indirect array).  Otherwise it returns 3nil*.
.end_defun

.defun array-indirect-p array
2array* may be any kind of array.
This predicate returns 3t* if 2array* is an indirect array.
Otherwise it returns 3nil*.
.end_defun

.defun array-indexed-p array
2array* may be any kind of array.
This predicate returns 3t* if 2array* is an indirect array with an index-offset.
Otherwise it returns 3nil*.
.end_defun

.defun array-has-leader-p array
2array* may be any array.  This predicate returns 3t* if 2array*
has a leader; otherwise it returns 3nil*.
.end_defun

.defun array-leader-length array
2array* may be any array.  This returns the length of 2array*'s leader
if it has one, or 3nil* if it does not.
.end_defun


.section Changing the Size of an Array

.defun adjust-array-size array new-size
If 2array* is a one-dimensional array, its size is
changed to be 2new-size*.  If 2array* has more than one
dimension, its size (3array-length*) is changed to 2new-size*
by changing only the last dimension.

If 2array* is made smaller, the extra elements are lost; if 2array*
is made bigger, the new elements are initialized in the same fashion as
3make-array* (see (make-array-fun)) would initialize them: either to 3nil* or 30*,
depending on the type of array.
.lisp
.exdent 96 Example:
(setq a (make-array 5))
(aset 'foo a 4)
(aref a 4) => foo
(adjust-array-size a 2)
(aref a 4) => 1an error occurs*
.end_lisp
	If the size of the array is being increased,
3adjust-array-size* may have to allocate a new array somewhere.  In
that case, it alters 2array* so that references to it will be made to
the new array instead, by means of "invisible pointers" (see
3structure-forward*, (structure-forward-fun)).
3adjust-array-size* will return this new array if it creates one, and
otherwise it will return 2array*.  Be careful to be consistent about
using the returned result of 3adjust-array-size*, because you may end
up holding two arrays which are not the same (i.e. not 3eq*), but
which share the same contents.
.end_defun

.defun array-grow array &rest dimensions
3array-grow* creates a new array of the same type as 2array*,
with the specified dimensions.  Those elements of 2array* that
are still in bounds are copied into the new array.  The elements of
the new array that are not in the bounds of 2array* are initialized
to 3nil* or 30* as appropriate.  If 2array* has a leader, the new
array will have a copy of it.  3array-grow* returns the new array
and also forwards 2array* to it, like 3adjust-array-size*.

Unlike 3adjust-array-size*, 3array-grow* always creates a new array
rather than growing or shrinking the array in place.  But 3array-grow*
of a multi-dimensional array can change all the subscripts and move
the elements around in memory to keep each element at the same logical
place in the array.
.end_defun

.defun return-array array
This peculiar function attempts to return 2array* to free storage.
If it is displaced, this returns the displaced array itself, not the
data that the array points to.  Currently 3return-array* does nothing if the array is
not at the end of its region, i.e. if it was not the most recently allocated
non-list object in its area.  This will eventually be renamed to
3reclaim*, when it works for other objects than arrays.

If you still have any references to 2array* anywhere in the Lisp world
after this function returns, the garbage collector can get a fatal error
if it sees them.  Since the form that calls this function must get the
array from somewhere, it may not be clear how to legally call 3return-array*.
One of the only ways to do it is as follows:
.lisp
(defun func ()
   (let ((array (make-array 100)))
      ...
      (return-array (prog1 array (setq array nil)))))
.end_lisp
so that the variable 3array* does not refer to the array when 3return-array*
is called.  You should only call this function if you know what you are doing;
otherwise the garbage collector can get fatal errors.  Be careful.
.end_defun

.section Arrays Overlaid With Lists

These functions manipulate 3art-q-list* arrays, which were
introduced on (art-q-list-var).

.defun g-l-p array
.c This will probably be renamed, if anyone can think of a better name
2array* should be an 3art-q-list* array.  This returns
a list which shares the storage of 2array*.
.lisp
.exdent 96 Example:
(setq a (make-array 4 ':type 'art-q-list))
(aref a 0) => nil
(setq b (g-l-p a)) => (nil nil nil nil)
(rplaca b t)
b => (t nil nil nil)
(aref a 0) => t
(aset 30 a 2)
b => (t nil 30 nil)
.end_lisp
.end_defun

.nopara
The following two functions work strangely, in the same way that 3store*
does, and should not be used in new programs.

.defun get-list-pointer-into-array array-ref
.c This will probably be renamed, if anyone can think of a better name
The argument 2array-ref* is ignored, but should be a reference
to an 3art-q-list* array by applying the array to subscripts (rather
than by 3aref*).  This returns a list object which
is a portion of the "list" of the array, beginning with the last
element of the last array which has been called as a function.
.end_defun

.defun get-locative-pointer-into-array array-ref
.c This will probably be flushed?
3get-locative-pointer-into-array* is
similar to 3get-list-pointer-into-array*, except that it returns a
locative, and doesn't require the array to be 3art-q-list*.
Use 3aloc* instead of this function in new programs.
.end_defun

.section Adding to the End of an Array

.defun array-push array x
2array* must be a one-dimensional array which has a fill pointer, and 2x* may
be any object.  3array-push* attempts to store 2x* in the element
of the array designated by the fill pointer, and increase the fill pointer
by one.  If the fill pointer does not designate an element of the array (specifically,
when it gets too big), it is unaffected and 3array-push* returns 3nil*;
otherwise, the two actions (storing and incrementing) happen uninterruptibly,
and 3array-push* returns the 2former* value of the fill pointer,
i.e. the array index in which it stored 2x*.  If the array is of type
3art-q-list*, an operation similar to 3nconc* has taken place,
in that the element has been added to the list by changing the cdr of
the formerly last element.  The cdr coding is updated to ensure this.
.end_defun

.defun array-push-extend array x &optional extension
3array-push-extend* is just like 3array-push* except
that if the fill pointer gets too large, the array is grown
to fit the new element; i.e. it never "fails" the way 3array-push* does,
and so never returns 3nil*.  2extension* is the number of
elements to be added to the array if it needs to be grown.  It defaults
to something reasonable, based on the size of the array.
.end_defun

.defun array-pop array
2array* must be a one-dimensional array which has a fill pointer.
The fill pointer is decreased by one, and the array element
designated by the new value of the fill pointer is returned.
If the new value does not designate any element of the array
(specifically, if it had already reached zero), an error is caused.
The two operations (decrementing and array referencing) happen
uninterruptibly.  If the array is of type 3art-q-list*, an operation
similar to 3nbutlast* has taken place.  The cdr coding is
updated to ensure this.
.end_defun


.section Copying an Array

.defun fillarray array x
	2array* may be any type of array, or, for Maclisp
compatibility, a symbol whose function cell contains an array.  There
are two forms of this function, depending on the type of 2x*. 
	If 2x* is a list, then 3fillarray* fills up 2array* with
the elements of 2list*.  If 2x* is too short to fill up all of
2array*, then the last element of 2x* is used to fill the
remaining elements of 2array*.  If 2x* is too long, the extra
elements are ignored.  If 2x* is 3nil* (the empty list), 2array*
is filled with the default initial value for its array type (3nil* or 30*).
	If 2x* is an array (or, for Maclisp compatibility, a symbol
whose function cell contains an array), then the elements of 2array* are
filled up from the elements of 2x*.  If 2x* is too small, then
the extra elements of 2array* are not affected.
	If 2array* is multi-dimensional, the elements are accessed
in row-major order: the last subscript varies the most quickly.
The same is true of 2x* if it is an array.
	3fillarray* returns 2array*.
.end_defun

.defun listarray array &optional limit
	2array* may be any type of array, or, for Maclisp
compatibility, a symbol whose function cell contains an array.  
3listarray* creates and returns a list whose elements are those of
2array*.  If 2limit* is present, it should be a fixnum, and only
the first 2limit* (if there are more than that many) elements of
2array* are used, and so the maximum length of the returned list is
2limit*. 
	If 2array* is multi-dimensional, the elements are accessed
in row-major order: the last subscript varies the most quickly.
.end_defun

.defun list-array-leader array &optional limit
2array* may be any type of array, or, for Maclisp
compatibility, a symbol whose function cell contains an array.  
3list-array-leader* creates and returns a list whose elements are those of
2array*'s leader.  If 2limit* is present, it should be a fixnum, and only
the first 2limit* (if there are more than that many) elements of
2array*'s leader are used, and so the maximum length of the returned list is
2limit*. If 2array* has no leader, 3nil* is returned.
.end_defun

.defun copy-array-contents from to
2from* and 2to* must be arrays.  The contents of 2from*
is copied into the contents of 2to*, element by element.
If 2to* is shorter than 2from*,
the rest of 2from* is ignored.  If 2from* is shorter than
2to*, the rest of 2to* is filled with 3nil* if it
is a q-type array, or 0 if it is a numeric array or a string,
or 0.0 if it is a flonum array.
This function always returns 3t*.

Note that even if 2from* or 2to* has a leader, the whole array
is used; the convention that leader element 0 is the "active" length
of the array is not used by this function.  The leader itself is not
copied.

3copy-array-contents* works on multi-dimensional arrays.  2from*
and 2to* are "linearized" subscripts, and column-major order is used,
2i.e. the first subscript varies fastest (opposite from 3fillarray*).*
.end_defun

.defun copy-array-contents-and-leader from to
This is just like 3copy-array-contents*, but the leader of 2from*
(if any) is also copied into 2to*.  3copy-array-contents* copies only
the main part of the array.
.end_defun

.defun copy-array-portion from-array from-start from-end to-array to-start to-end
The portion of the array 2from-array* with indices greater than or
equal to 2from-start* and less than 2from-end* is copied into
the portion of the array 2to-array* with indices greater than or
equal to 2to-start* and less than 2to-end*, element by element.
If there are more elements in the selected portion of 2to-array*
than in the selected portion of 2from-array*, the extra elements
are filled with the default value as by 3copy-array-contents*.
If there are more elements in the selected portion of 2from-array*,
the extra ones are ignored.  Multi-dimensional arrays are treated
the same way as 3copy-array-contents* treats them.
This function always returns 3t*.
.end_defun

.defun bitblt alu width height from-array from-x from-y to-array to-x to-y
2from-array* and 2to-array* must be two-dimensional arrays
of bits or bytes (3art-1b*, 3art-2b*, 3art-4b*, 3art-8b*,
3art-16b*, or 3art-32b*).  3bitblt* copies a rectangular portion of 2from-array*
into a rectangular portion of 2to-array*.  The value stored
can be a Boolean function of the new value and the value already there,
under the control of 2alu* (see below).  This function is most commonly used
in connection with raster images for TV displays.

The top-left corner of the source rectangle is 3(aref 2from-array*
2from-x* 2from-y*)*.  The top-left corner of the destination
rectangle is 3(aref 2to-array* 2to-x* 2to-y*)*.  2width*
and 2height* are the dimensions of both rectangles.  If 2width*
or 2height* is zero, 3bitblt* does nothing.

2from-array* and 2to-array* are allowed to be the same array.
3bitblt* normally traverses the arrays in increasing order of 2x*
and 2y* subscripts.  If 2width* is negative, then 3(abs 2width*)*
is used as the width, but the processing of the 2x* direction is done
backwards, starting with the highest value of 2x* and working down.
If 2height* is negative it is treated analogously.  When
3bitblt*'ing an array to itself, when the two rectangles overlap, it
may be necessary to work backwards to achieve the desired effect, such
as shifting the entire array upwards by a certain number of rows.  Note
that negativity of 2width* or 2height* does not affect the
2(x,y)* coordinates specified by the arguments, which are still the
top-left corner even if 3bitblt* starts at some other corner.

If the two arrays are of different types, 3bitblt* works bit-wise
and not element-wise.  That is, if you 3bitblt* from an 3art-2b*
array into an 3art-4b* array, then two elements of the 2from-array*
will correspond to one element of the 2to-array*.

If 3bitblt* goes outside the bounds of the source array, it wraps
around.  This allows such operations as the replication of a small
stipple pattern through a large array.  If 3bitblt* goes outside
the bounds of the destination array, it signals an error.

If 2src* is an element of the source rectangle, and 2dst*
is the corresponding element of the destination rectangle, then
3bitblt* changes the value of 2dst* to
3(boole 2alu* 2src* 2dst*)*.  See the 3boole*
function ((boole-fun)).  There are symbolic names for some of the
most useful 2alu* functions; they are 3tv:alu-seta* (plain
copy), 3tv:alu-ior* (inclusive or), 3tv:alu-xor* (exclusive
or), and 3tv:alu-andca* (and with complement of source).

3bitblt* is written in highly-optimized microcode and goes very much
faster than the same thing written with ordinary 3aref* and 3aset*
operations would.  Unfortunately this causes 3bitblt* to have a couple
of strange restrictions.  Wrap-around does not work correctly if
2from-array* is an indirect array with an index-offset.  3bitblt*
will signal an error if the first dimensions of 2from-array*
and 2to-array* are not both integral multiples of the machine word
length.  For 3art-1b* arrays, the first dimension must be a multiple
of 32., for 3art-2b* arrays it must be a multiple of 16., etc.
.end_defun


.section Matrices and Systems of Linear Equations

The functions in this section perform some useful matrix operations.
The matrices are represented as two-dimensional Lisp arrays.
These functions are part of the mathematics package rather than
the kernel array system, hence the "3math:*" in the names.

.defun math:multiply-matrices matrix-1 matrix-2 &optional matrix-3
Multiplies 2matrix-1* by 2matrix-2*.  If 2matrix-3* is supplied,
3multiply-matrices* stores the results into 2matrix-3* and returns
2matrix-3*; otherwise it creates an array to contain the answer and
returns that.  All matrices must be two-dimensional arrays, and the first
dimension of 2matrix-2* must equal the second dimension of 2matrix-1*.
.end_defun

.defun math:invert-matrix matrix &optional into-matrix
Computes the inverse of 2matrix*.  If 2into-matrix* is supplied,
stores the result into it and returns it; otherwise it creates an array
to hold the result, and returns that.  2matrix* must be two-dimensional
and square.  The Gauss-Jordan algorithm with partial pivoting is used.
Note: if you want to solve a set of simultaneous equations, you should
not use this function; use 3math:decompose* and 3math:solve* (see below).
.end_defun

.defun math:transpose-matrix matrix &optional into-matrix
Transposes 2matrix*.  If 2into-matrix* is supplied, stores the
result into it and returns it; otherwise it creates an array to hold the
result, and returns that.  2matrix* must be a two-dimensional array.
2into-matrix*, if provided, must be two-dimensional and have sufficient
dimensions to hold the transpose of 2matrix*.
.end_defun

.defun math:determinant matrix
Returns the determinant of 2matrix*.  2matrix* must be a two-dimensional
square matrix.
.end_defun

The next two functions are used to solve sets of simultaneous linear
equations.  3math:decompose* takes a matrix holding the coefficients of the
equations and produces the LU decomposition; this decomposition can then
be passed to 3math:solve* along with a vector of right-hand sides
to get the values of the variables.  If you want to solve the same
equations for many different sets of right-hand side values, you only need to call
3math:decompose* once.  In terms of the argument names used below, these
two functions exist to solve the vector equation 2A* 2x* = 2b*
for 2x*.  2A* is a matrix.  2b* and 2x* are vectors.

.defun math:decompose a &optional lu ps
Computes the LU decomposition of matrix 2a*.  If 2lu* is non-3nil*,
stores the result into it and returns it; otherwise it creates an array
to hold the result, and returns that.  The lower triangle of 2lu*, with
ones added along the diagonal, is L, and the upper triangle of 2lu* is
U, such that the product of L and U is 2a*.  Gaussian elimination with
partial pivoting is used.  The 2lu* array is permuted by rows according
to the permutation array 2ps*, which is also produced by this function;
if the argument 2ps* is supplied, the permutation array is stored into it;
otherwise, an array is created to hold it.  This function returns two values:
the LU decomposition and the permutation array.
.end_defun

.defun math:solve lu ps b &optional x
This function takes the LU decomposition and associated permutation
array produced by 3math:decompose*, and solves the set of simultaneous
equations defined by the original matrix 2a* and the right-hand sides
in the vector 2b*.  If 2x* is supplied, the solutions
are stored into it and it is returned; otherwise, an array is
created to hold the solutions and that is returned.  2b* must
be a one-dimensional array.
.end_defun

.defun math:list-2d-array array
Returns a list of lists containing the values in 2array*, which must
be a two-dimensional array.  There is one element for each row; each
element is a list of the values in that row.
.end_defun

.defun math:fill-2d-array array list
This is the opposite of 3math:list-2d-array*.  2list* should be a
list of lists, with each element being a list corresponding to a row.
2array*'s elements are stored from the list.  Unlike 3fillarray*
(see (fillarray-fun)), if 2list* is not long enough,
3math:fill-2d-array* "wraps around", starting over at the beginning.
The lists which are elements of 2list* also work this way.
.end_defun

.section Planes
.cindex plane

A 2plane* is an array whose bounds, in each dimension,
are plus-infinity and minus-infinity; all integers are legal as indices.
Planes are distinguished not by size and shape, but by number of dimensions alone.
When a plane is created, a default value must be specified.
At that moment, every component of the plane has that value.
As you can't ever change more than a finite number of components,
only a finite region of the plane need actually be stored.

The regular array accessing functions don't work on planes.
You can use 3make-plane* to create a plane,
3plane-aref* or 3plane-ref* to get the value of a component, and
3plane-aset* or 3plane-store* to store into a component.
3array-#-dims* will work on a plane.

A plane is actually stored as an array with a leader.
The array corresponds to a rectangular, aligned region of the plane,
containing all the components in which a 3plane-store* has been done
(and others, in general, which have never been altered).
The lowest-coordinate corner of that rectangular region is
given by the 3plane-origin* in the array leader.
The highest coordinate corner can be found by adding the 3plane-origin*
to the 3array-dimensions* of the array.
The 3plane-default* is the contents of all the
elements of the plane which are not actually stored in the array.
The 3plane-extension* is the amount to extend a plane by in any direction
when the plane needs to be extended.  The default is 32.

If you never use any negative indices, then the 3plane-origin* will
be all zeroes and you can use regular array functions, such as 3aref* and 3aset*,
to access the portion of the plane which is actually stored.  This can be
useful to speed up certain algorithms.  In this case you can even use the
3bitblt* function on a two-dimensional plane of bits or bytes,
provided you don't change the 3plane-extension* to a number that is not
a multiple of 32.

.defun make-plane rank &rest options
Creates and returns a plane. 2rank* is the number of dimensions.  2options*
is a list of alternating keyword symbols and values.  The allowed keywords are:
.table 3
.kitem :type
The array type symbol (e.g. 3art-1b*) specifying the type of the array
out of which the plane is made.
.kitem :default-value
The default component value as explained above.
.kitem :extension
The amount by which to extend the plane, as explained above.
.end_table
Example:
.lisp
(make-plane 2 ':type 'art-4b ':default-value 3)
.end_lisp
creates a two-dimensional plane of type 3art-4b*, with default value 33*.
.end_defun

.defun plane-origin plane
A list of numbers, giving the lowest coordinate values actually stored.
.end_defun

.defun plane-default plane
This is the contents of the infinite number of plane elements which are
not actually stored.
.end_defun

.defun plane-extension plane
The amount to extend the plane by in any direction when 3plane-store* is done
outside of the currently-stored portion.
.end_defun

.defun plane-aref plane &rest subscripts
.defun1 plane-ref plane subscripts
These two functions return the contents of a specified element of a plane.
They differ only in the way they take their arguments; 3plane-aref* wants
the subscripts as arguments, while 3plane-ref* wants a list of subscripts.
.end_defun

.defun plane-aset datum plane &rest subscripts
.defun1 plane-store datum plane subscripts
These two functions store 2datum* into the specified element of a plane,
extending it if necessary, and return 2datum*.
They differ only in the way they take their arguments; 3plane-aset* wants
the subscripts as arguments, while 3plane-store* wants a list of subscripts.
.end_defun


.section "Maclisp Array Compatibility"
.setq maclisp-array section-page

The functions in this section are provided only for Maclisp compatibility,
and should not be used in new programs.

	Fixnum arrays do not exist (however, see Zetalisp's
small-positive-integer arrays).  Flonum arrays exist but you do not use
them in the same way; no declarations are required or allowed.
"Un-garbage-collected" arrays do not exist.
'c yet??? --weak links
Readtables and obarrays are represented as arrays, but unlike Maclisp special
array types are not used.  See the descriptions
of 3read* ((read-fun)) and 3intern* ((intern-fun)) for
information about readtables and obarrays (packages).
There are no "dead" arrays, nor are Multics "external" arrays provided.

The 3arraycall* function exists for compatibility
but should not be used (see 3aref*, (aref-fun).)

Subscripts are always checked for validity, regardless of the value
of 3*rset* and whether the code is compiled or not. 
However, in a multi-dimensional array, an error is only caused
if the subscripts would have resulted in a reference to storage
outside of the array. For example, if you have a 2 by 7 array and refer
to an element with subscripts 3 and 1, no error will
be caused despite the fact that the reference is invalid;
but if you refer to element 1 by 100, an error will be caused.
In other words, subscript errors will be caught if and only if
they refer to storage outside the array; some errors are undetected,
but they will only clobber some other element of the same array
rather than clobbering something completely unpredictable.

Currently, multi-dimensional arrays are stored in column-major order
rather than row-major order as in Maclisp.  See (column-major)
for further discussion of this issue.

3loadarrays* and 3dumparrays* are not provided.  However,
arrays can be put into "QFASL" files; see (fasdump).

	The 3*rearray* function is not provided, since not all
of its functionality is available in Zetalisp.
The most common uses can be replaced by 3adjust-array-size*.

	In Maclisp, arrays are usually kept on the 3array* property
of symbols, and the symbols are used instead of the arrays.  In order
to provide some degree of compatibility for this manner of using
arrays, the 3array*, 3*array*, and 3store* functions are
provided, and when arrays are applied to arguments, the arguments are
treated as subscripts and 3apply* returns the corresponding element
of the array.

.defun array &quote symbol type &eval &rest dims
	This creates an 3art-q* type array in 3default-array-area*
with the given dimensions.  (That is, 2dims* is given
to 3make-array* as its first argument.)  2type* is ignored.
If 2symbol* is 3nil*, the array is returned; otherwise,
the array is put in the function cell of 2symbol*, and 2symbol*
is returned.
.end_defun

.defun *array symbol type &rest dims
	This is just like 3array*, except that all of the arguments
are evaluated.
.end_defun

.defspec store array-ref x
3store* stores 2x* into the
specified array element.  2array-ref* should be a form which
references an array by calling it as a function (3aref* forms are not
acceptable).  First 2x* is evaluated, then 2array-ref* is
evaluated, and then the value of 2x* is stored into the array cell
last referenced by a function call, presumably the one in 2array-ref*.
.end_defspec

.defun xstore x array-ref
	This is just like 3store*, but it is not
a special form; this is because the arguments are in the other
order.  This function only exists for the compiler to compile the
3store* special form into, and should never be used by programs.
.end_defun

.defun arraycall ignored array &rest subscripts
3(arraycall t 2array* 2sub1* 2sub2*...)* is the same
as 3(aref 2array* 2sub1* 2sub2*...)*.  It exists for
Maclisp compatibility.
.end_defun
