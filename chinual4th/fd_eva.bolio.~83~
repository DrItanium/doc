.c This file is part of the Lisp Machine Manual.  -*-Bolio-*-
.c  Function Description: Evaluator >
.chapter "Evaluation"
.setq evaluator-chapter chapter-number
'cindex "evaluation"
.setq description-of-evaluation page

.c Somewhere we should explain why sstatus uuolinks isn't needed.

	The following is a complete description of the actions taken by the
evaluator, given a 2form* to evaluate.

	If 2form* is a number, the result is 2form*.

	If 2form* is a string, the result is 2form*.

	If 2form* is a symbol, the result is the binding of 2form*.
If 2form* is unbound, an error is signalled.  The way symbols are
bound is explained in (variable-section) below.

	If 2form* is not any of the above types, and is not a list,
an error is signalled.

	In all remaining cases, 2form* is a list.  The evaluator
examines the 3car* of the list to figure out what to do next.  There
are three possibilities: this form may be a 2special form*, a 2macro
form*, or a plain-old 2function form*.  Conceptually, the evaluator
knows specially about all the symbols whose appearance in the 3car* of a
form make that form a special form, but the way the evaluator actually
works is as follows.  If the 3car* of the form is a symbol, the evaluator
finds the object in the function cell of the symbol (see (symbol)) and
starts all over as if that object had been the 3car* of the list.  If the
3car* isn't a symbol, then if it's a cons whose 3car* is the symbol
3macro*, then this is a macro form; if it is a "special function" (see
(special-function)) then this is a special form; otherwise, it should
be a regular function, and this is a function form.

	If 2form* is a special form, then it is handled accordingly;
each special form works differently.  All of them are documented in this
manual.  The internal workings of special forms are explained in more
detail on (special-function), but this hardly ever affects you.

	If 2form* is a macro form, then the macro is expanded as
explained in chapter (macros-chapter).

	If 2form* is a function form, it calls for the 2application*
of a function to 2arguments*.  The 3car* of the form is a function
or the name of a function.  The 3cdr* of the form is a list of
subforms.  Each subform is evaluated, sequentially.  The values produced
by evaluating the subforms are called the "arguments" to the function.
The function is then applied to those arguments.  Whatever results the
function 2returns* are the values of the original 2form*.

	There is a lot more to be said about evaluation.  The way variables
work and the ways in which they are manipulated, including the binding of
arguments, is explained in (variable-section).  A basic explanation of
functions is in (function-section).  The way functions can return more
than one value is explained in (multiple-value).  The description of all
of the kinds of functions, and the means by which they are manipulated, is
in chapter (function-chapter).  Macros are explained in chapter
(macros-chapter).  The 3evalhook* facility, which lets you do something
arbitrary whenever the evaluator is invoked, is explained in
(evalhook-section).  Special forms are described all over the manual; each
special form is in the section on the facility it is part of.


.section Variables
.setq variable-section section-page

In Zetalisp, variables are implemented using symbols.  Symbols
are used for many things in the language, such as naming functions,
naming special forms, and being keywords; they are also useful to
programs written in Lisp, as parts of data structures.  But when the
evaluator is given a symbol, it treats it as a variable, using the value
cell to hold the value of the variable.  If you evaluate a symbol, you
get back the contents of the symbol's value cell.

There are two different ways of changing the value of a variable.  One
is to 2set* the variable.  Setting a variable changes its value to a
new Lisp object, and the previous value of the variable is forgotten.
Setting of variables is usually done with the 3setq* special form.

The other way to change the value of a variable is with 2binding*
(also called "lambda-binding").  When a variable is bound, its old value
is first saved away, and then the value of the variable is made to be
the new Lisp object.  When the binding is undone, the saved value is
restored to be the value of the variable.  Bindings are always followed
by unbindings.  The way this is enforced is that binding is only done by
special forms that are defined to bind some variables, then evaluate some
subforms, and then unbind those variables.  So the variables are all
unbound when the form is finished.  This means that the evaluation of
the form doesn't disturb the values of the variables that are bound;
whatever their old value was, before the evaluation of the form, gets
restored when the evaluation of the form is completed.  If such a form
is exited by a non-local exit of any kind, such as 3*throw* (see
(*throw-fun)) or 3return* (see (return-fun)), the bindings are
undone whenever the form is exited.

The simplest construct for binding variables is the 3let* special
form.  The 3do* and 3prog* special forms can also bind variables, in
the same way 3let* does, but they also control the flow of the program
and so are explained elsewhere (see (do-fun)).  3let** is just a
sequential version of 3let*; the other special forms below are only
used for esoteric purposes.

Binding is an important part of the process of applying interpreted
functions to arguments.  This is explained in the next section.

'cindex local variable
When a Lisp function is compiled, the compiler understands the use of
symbols as variables.  However, the compiled code generated by the
compiler does not actually use symbols to represent variables.  Rather,
the compiler converts the references to variables within the program
into more efficient references, that do not involve symbols at all.  A
variable that has been changed by the compiler so that it is not
implemented as a symbol is called a "local" variable.  When a local
variable is bound, a memory cell is allocated in a hidden, internal
place (the Lisp control stack) and the value of the variable is
stored in this cell.  You cannot use a local variable without first
binding it; you can only use a local variable inside of a special form
that binds that variable.  Local variables do not have any "top level"
value; they do not even exist outside of the form that binds them.

'cindex special variable
The variables which are associated with symbols (the kind which
are used by non-compiled programs) are called "special" variables.

Local variables and special variables do not behave quite the same way,
because "binding" means different things for the two of them.  Binding a
special variable saves the old value away and then uses the value
cell of the symbol to hold the new value, as explained above.  Binding
a local variable, however, does not do anything to the symbol.  In fact,
it creates a new memory cell to hold the value, i.e. a new local variable.

Thus, if you compile a function, it may do different things after it has
been compiled.  Here is an example:

.lisp
(setq a 2)	      ;1Set the variable 3a* to the value 32*.*

(defun foo ()	      ;1Define a function named 3foo*.*
  (let ((a 5))	      ;1Bind the symbol 3a* to the value 35*.*
    (bar)))	      ;1Call the function 3bar*.*

(defun bar ()	      ;1Define a function named 3bar*.*
  a)		      ;1It just returns the value of the variable 3a*.*

(foo) => 5	      ;1Calling 3foo* returns 35*.*

(compile 'foo)	      ;1Now compile 3foo*.*

(foo) => 2	      ;1This time, calling 3foo* returns 32*.*
.end_lisp

This is a very bad thing, because the compiler is only supposed to speed
things up, without changing what the function does.  Why did the function
3foo* do something different when it was compiled?  Because 3a* was
converted from a special variable into a local variable.  After 3foo* was
compiled, it no longer had any effect on the value cell of the symbol 3a*,
and so the symbol retained its old contents, namely 32*.

In most uses of variables in Lisp programs, this problem doesn't come
up.  The reason it happened here is because the function 3bar* refers
to the symbol 3a* without first binding 3a* to anything.  A
reference to a variable that you didn't bind yourself is called a 2free
reference*; in this example, 3bar* makes a free reference to 3a*.

We mentioned above that you can't use a local variable without first
binding it.  Another way to say this is that you can't ever have a free
reference to a local variable.  If you try to do so, the compiler will
complain.  In order for our functions to work, the compiler must be told
2not* to convert 3a* into a local variable; 3a* must remain a
special variable.  Normally, when a function is compiled, all variables
in it are made to be "local".  You can stop the compiler from making a
variable local by "declaring" to the compiler that the variable is
"special".  When the compiler sees references to a variable that has
been declared special, it uses the symbol itself as the variable instead
of making a local variable.

Variables can be declared by the special forms 3defvar* and
3defconst* (see below), or by explicit compiler declarations (see
(special-fun)).  The most common use of special variables is as
"global" variables: variables used by many different functions
throughout a program, that have top-level values.

Had 3bar* been compiled, the compiler would have seen the free
reference and printed a warning message: 3Warning: a declared
special.*  It would have automatically declared 3a* to be special and
proceeded with the compilation.  It knows that free references mean that
special declarations are needed.  But when a function is compiled that
binds a variable that you want to be treated as a special variable but
that you have not explicitly declared, there is, in general, no way for
the compiler to automatically detect what has happened, and it will
produce incorrect output.  So you must always provide declarations for
all variables that you want to be treated as special variables.

When you declare a variable to be special using 3declare* rather than
3local-declare*, the declaration is "global"; that is, it applies
wherever that variable name is seen.  After 3fuzz* has been declared
special using 3declare*, all following uses of 3fuzz* will be
treated by the compiler as references to the same special variable.
Such variables are called "global variables", because any function can
use them; their scope is not limited to one function.  The special forms
3defvar* and 3defconst* are useful for creating global variables;
not only do they declare the variable special, but they also provide a
place to specify its initial value, and a place to add documentation.
In addition, since the names of these special forms start with "3def*" and
since they are used at the top-level of files, the Lisp Machine editor
can find them easily.

Here are the special forms used for setting variables.

.defspec setq {variable value}...
The 3setq* special form is used to set the value of a variable or of
many variables.  The first 2value* is evaluated, and the first
2variable* is set to the result.  Then the second 2value* is
evaluated, the second 2variable* is set to the result, and so on for
all the variable/value pairs.  3setq* returns the last value, i.e.
the result of the evaluation of its last subform.
.lisp
.exdent 96 Example:
(setq x (+ 3 2 1) y (cons x nil))
.end_lisp
3x* is set to 36*, 3y* is set to 3(6)*, and the 3setq* form
returns 3(6)*.  Note that the first variable was set before
the second value form was evaluated, allowing that form to use the new value of 3x*.
.end_defspec

.defspec psetq {variable value}...
A 3psetq* form is just like a 3setq* form, except
that the variables are set "in parallel"; first all of the 2value* forms
are evaluated, and then the 2variables* are set to the resulting
values.
.lisp
.exdent 96 Example:
(setq a 1)
(setq b 2)
(psetq a b b a)
a => 2
b => 1
.end_lisp
.end_defspec

Here are the special forms used for binding variables.

.defspec let ((var value)...) body...
3let* is used to bind some variables to some objects, and evaluate some forms
(the "body") in the context of those bindings.
A 3let* form looks like
.lisp
(let ((2var1* 2vform1*)
      (2var2* 2vform2*)
      ...)
  2bform1*
  2bform2*
  ...)
.end_lisp
When this form is evaluated, first the 2vforms* (the values) are evaluated.
Then the 2vars* are bound to the values returned by the
corresponding 2vforms*.  Thus the bindings happen in parallel;
all the 2vforms* are evaluated before any of the 2vars* are bound.
Finally, the 2bforms* (the body) are evaluated sequentially, the old values
of the variables are restored, and the result of the last 2bform* is returned.

You may omit the 2vform* from a 3let* clause, in which case it is as
if the 2vform* were 3nil*: the variable is bound to 3nil*.
Furthermore, you may replace the entire clause (the list of the variable
and form) with just the variable, which also means that the variable
gets bound to 3nil*.  Example:
.lisp
(let ((a (+ 3 3))
      (b 'foo)
      (c)
      d)
  ...)
.end_lisp
Within the body, 3a* is bound to 36*, 3b* is bound to 3foo*, 3c* is
bound to 3nil*, and 3d* is bound to 3nil*.
.end_defspec

.defspec let* ((var value)...) body...
3let** is the same as 3let* except that the binding is sequential.  Each
2var* is bound to the value of its 2vform* before the next 2vform*
is evaluated.  This is useful when the computation of a 2vform* depends on
the value of a variable bound in an earlier 2vform*.  Example:
.lisp
(let* ((a (+ 1 2))
       (b (+ a a)))
 ...)
.end_lisp
Within the body, 3a* is bound to 33* and 3b* is bound to 36*.
.end_defspec

.defspec let-if condition ((var value)...) body...
3let-if* is a variant of 3let* in which the binding of variables is conditional.
The variables must all be special variables.
The 3let-if* special form, typically written as
.lisp
(let-if 2cond*
	((2var-1* 2val-1*) (2var-2* 2val-2*)...)
  2body-form1* 2body-form2*...)
.end_lisp
first evaluates the predicate form 2cond*.  If the result is non-3nil*, the value forms
2val-1*, 2val-2*, etc. are evaluated and then the variables 2var-1*, 2var-2*,
etc. are bound to them.  If the result is 3nil*, the
2vars* and 2vals* are ignored.  Finally the body forms are evaluated.
.end_defspec

.defspec let-globally ((var value)...) body...
3let-globally* is similar in form to 3let* (see (let-fun)).
The difference is that 3let-globally* does not 2bind* the
variables; instead, it saves the old values and 2sets* the variables,
and sets up an 3unwind-protect*
(see (unwind-protect-fun)) to set them back.  The important
difference between 3let-globally* and 3let* is that when
the current stack group (see (stack-group)) co-calls some other stack
group, the old values of the variables are 2not* restored.  Thus
3let-globally* makes the new values visible in all stack groups and
processes that don't bind the variables themselves, not just the current stack group.
.end_defspec

.defspec progv symbol-list value-list body...
3progv* is a special form to provide the user with extra control
over binding.  It binds a list of special variables to a list of values,
and then evaluates some forms.  The lists of special variables and values
are computed quantities; this is what makes 3progv* different from
3let*, 3prog*, and 3do*.

3progv* first evaluates 2symbol-list* and 2value-list*, and then binds each
symbol to the corresponding value.  If too few values are supplied, the
remaining symbols are bound to 3nil*.  If too many values are
supplied, the excess values are ignored.

After the symbols have been bound to the values, the 2body* forms are
evaluated, and finally the symbols' bindings are undone.
The result returned is the value of the last form in the body.
.lisp
.exdent 96 Example:
(setq a 'foo b 'bar)

(progv (list a b 'b) (list b)
  (list a b foo bar))
    => (foo nil bar nil)
.end_lisp
During the evaluation of the body of this 3progv*, 3foo*
is bound to 3bar*, 3bar* is bound to 3nil*, 3b* is
bound to 3nil*, and 3a* retains its top-level value 3foo*.
.end_defspec

.defspec progw vars-and-vals-form body...
3progw* is a somewhat modified kind of 3progv*.  Like 3progv*, it
only works for special variables.
First, 2vars-and-val-forms-form* is evaluated.  Its value should be a list
that looks like the first subform of a 3let*:
.lisp
  ((2var1* 2val-form-1*)
   (2var2* 2val-form-2*)
   ...)
.end_lisp
Each element of this list is processed in turn, by evaluating the 2val-form*,
and binding the 2var* to the resulting value.  Finally, the 2body* forms are
evaluated sequentially, the bindings are undone, and the result of the last
form is returned.  Note that the bindings are sequential, not parallel.

This is a very unusual special form because of the way the evaluator is
called on the result of an evaluation.  Thus 3progw* is mainly
useful for implementing special forms and for functions part of whose
contract is that they call the interpreter.  For an example of the latter,
see 3sys:*break-bindings** ((sys:*break-bindings*-var)); 3break* implements
this by using 3progw*.
.end_defspec

.nopara
Here are the special forms for defining special variables.

.defspec defvar variable [initial-value] [documentation]
3defvar* is the recommended way to declare the use of a global variable in a
program.  Placed at top level in a file,
.lisp
(defvar 2variable*)
.end_lisp
declares 2variable* special for the sake of compilation, and records
its location for the sake of the editor so that you can ask to see where
the variable is defined.  If a second subform is supplied,
.lisp
(defvar 2variable* 2initial-value*)
.end_lisp
2variable* is initialized to the result of evaluating the form
2initial-value* unless it already has a value, in which case it
keeps that value.  2initial-value*
is not evaluated unless it is used; this is useful if it does something
expensive like creating a large data structure.

3defvar* should be used only at top level, never in function
definitions, and only for global variables (those used by more than one
function).  3(defvar foo 'bar)* is roughly equivalent to
.lisp
(declare (special foo))
(if (not (boundp 'foo))
    (setq foo 'bar))
.end_lisp

.lisp
(defvar 2variable* 2initial-value* 2documentation*)
.end_lisp
allows you to include a documentation string which describes what the
variable is for or how it is to be used.   Using such a documentation
string is even better than commenting the use of the variable, because
the documentation string is accessible to system programs that can
show the documentation to you while you are using the machine.

If 3defvar* is used in a patch file (see (patch-facility))
or is a single form (not a region) evaluated with the editor's
compile/evaluate from buffer commands,
if there is an initial-value the variable is always set to it
regardless of whether it is already bound.
.end_defspec

.defspec defconst variable [initial-value] [documentation]
3defconst* is the same as 3defvar* except that if an initial value
is given the variable is always set to it regardless of whether it is
already bound.  The rationale for this is that 3defvar* declares a
global variable, whose value is initialized to something but will then
be changed by the functions that use it to maintain some state.  On the
other hand, 3defconst* declares a constant, whose value will never be
changed by the normal operation of the program, only by changes 2to* the program.
3defconst* always sets the variable to the specified value
so that if, while developing or debugging the program, you change your
mind about what the constant value should be, and then you evaluate the
3defconst* form again, the variable will get the new value.
It is 2not* the intent of 3defconst* to declare that the value of
2variable* will never change; for example, 3defconst* is 2not* license to the compiler
to build assumptions about the value of 2variable* into programs being compiled.
.end_defspec

.section Functions
.setq function-section section-page
.setq lambda-list section-page
.cindex lambda list

In the description of evaluation on (description-of-evaluation), we
said that evaluation of a function form works by applying the function
to the results of evaluating the argument subforms.  What is a function,
and what does it mean to apply it?  In Zetalisp there are many
kinds of functions, and applying them may do many different kinds of
things.  For full details, see (function-functions).  Here we will
explain the most basic kinds of functions and how they work.  In
particular, this section explains 2lambda lists* and all their
important features.

The simplest kind of user-defined function is the 2lambda-expression*,
which is a list that looks like:
.lisp
(lambda 2lambda-list* 2body1* 2body2*...)
.end_lisp
The first element of the lambda-expression is the symbol 3lambda*; the
second element is a list called the 2lambda list*, and the rest of the
elements are called the 2body*.  The lambda list, in its simplest
form, is just a list of variables.  Assuming that this simple form
is being used, here is what happens when a lambda expression is applied
to some arguments.  First, the number of arguments and the number of
variables in the lambda list must be the same, or else an error is signalled.
Each variable is bound to the corresponding argument value.  Then
the forms of the body are evaluated sequentially.  After this, the
bindings are all undone, and the value of the last form in the body is
returned.

This may sound something like the description of 3let*, above.  The
most important difference is that the lambda-expression is not a form at
all; if you try to evaluate a lambda-expression, you will get told that
3lambda* is not a defined function.  The lambda-expression is a
2function*, not a form.   A 3let* form gets evaluated, and the
values to which the variables are bound come from the evaluation of some
subforms inside the 3let* form; a lambda-expression gets applied, and
the values are the arguments to which it is applied.

.cindex parameters

The variables in the lambda list are sometimes called 2parameters*,
by analogy with other languages.  Some other terminologies would refer
to these as 2formal parameters*, and to arguments as 2actual parameters*.

Lambda lists can have more complex structure than simply being a list of
variables.  There are additional features accessible by using certain
keywords (which start with 3&*) and/or lists as elements of the
lambda list.

The principal weakness of the simple lambda lists is that any
function written with one must only take a certain, fixed number of
arguments.  As we know, many very useful functions, such as 3list*,
3append*, 3+*, and so on, accept a varying number of arguments.
Maclisp solved this problem by the use of 2lexprs* and 2lsubrs*,
which were somewhat inelegant since the parameters had to be referred to
by numbers instead of names (e.g. 3(arg 3)*).  (For compatibility
reasons, Zetalisp supports 2lexpr*s, but they should not be
used in new programs).  Simple lambda lists also require that
arguments be matched with parameters by their position in the
sequence.  This makes calls hard to read when there are a great many
arguments.  Keyword parameters enable the use of other styles of call
which are more readable.

.cindex "keyword parameters"
.cindex "positional parameters"
.cindex "optional parameters"
.cindex "required parameters"
.cindex "rest parameters"

	In general, a function in Zetalisp has zero or more
2positional* parameters, followed if desired by a single 2rest*
parameter, followed by zero or more 2keyword* parameters.  The
positional and keyword parameters may be 2required* or 2optional*,
but all the optional parameters must follow all the required ones.
The required/optional distinction does not apply to the rest
parameter.

The caller must provide enough arguments so that each of the required
parameters gets bound, but he may provide extra arguments, for some of
the optional parameters.  Also, if there is a rest parameter, he can
provide as many extra arguments as he wants, and the rest parameter
will be bound to a list of all these extras.  Optional parameters may
have a 2default-form*, which is a form to be evaluated to produce
the default value for the parameter if no argument is supplied.

Positional parameters are matched with arguments by the position of
the arguments in the argument list.  Keyword parameters are matched
with their arguments by matching the keyword name; the arguments need
not appear in the same order as the parameters.  If an optional
positional argument is omitted, then no further arguments can be
present.  Keyword parameters allow the caller to decide independently
for each one whether to specify it.
	Here is the exact explanation of how this all works.  When
3apply* (the primitive function that applies functions
to arguments) matches up the arguments with the parameters, it follows the
following algorithm: 
	The positional parameters are dealt with first.
	The first required positional parameter is bound to the first
argument.  3apply* continues to bind successive required
positional parameters
to the successive arguments.  If, during this process, there are no
arguments left but there are still some required parameters
(positional or keyword) which have
not been bound yet, it is an error ("too few arguments").
	Next, after all required parameters are handled, 3apply*
continues with the optional positional parameters, if any.  It binds
successive parameter to the next argument.  If, during this process, there are no arguments
left, each remaining optional parameter's default-form is evaluated,
and the parameter is bound to it.  This is done one parameter at a time;
that is, first one default-form is evaluated, and then the parameter is
bound to it, then the next default-form is evaluated, and so on.
This allows the default for an argument to depend on the previous argument.
	Now, if there are no remaining parameters (rest or keyword), and there are no
remaining arguments, we are finished.  If there are no more parameters
but there are still some arguments remaining, an error is caused ("too
many arguments").  If parameters remain, all the remaining arguments
are used for 2both* the rest parameter, if any, and the keyword
parameters.

	First, if there is a rest parameter, it is bound to a list of all
the remaining arguments.  If there are no
remaining arguments, it gets bound to 3nil*.
	If there are keyword parameters, the same remaining arguments are
used to bind them, as follows.
	The arguments for the keyword parameters are treated as a list
of alternating keyword symbols and associated values.  Each symbol is
matched with the keyword parameter names, and the matching keyword
paramater is bound to the value which follows the symbol.  All the
remaining arguments are treated in this way.  Since the arguments are
usually obtained by evaluation, those arguments which are keyword
symbols are typically quoted in the call; but they do not have to be.
The keyword symbols are compared by means of 3eq*, which means they
must be specified in the correct package.  The keyword symbol for a
parameter has the same print name as the parameter, but resides in the
keyword package regardless of what package the parameter name itself
resides in.  (You can specify the keyword symbol explicitly in the
lambda list if you must; see below).
	If any keyword parameter has not received a value when all the
arguments have been processed, this is an error if the parameter is
required.  If it is optional, the default-form for the parameter is
evaluated and the parameter is bound to its value.
	There may be a keyword symbol among the arguments which does not match any
keyword parameter name.  The function itself specifies whether this is
an error.  If it is not an error, then the non-matching symbols and
their associated values are ignored.  The function can access these
symbols and values through the rest parameter, if there is one.
It is common for a function to check only for certain keywords, and
pass its rest parameter to another function using 3lexpr-funcall*;
then that function will check for the keywords that concern it.
	The way you express which parameters are required, optional,
and rest is by means of specially recognized symbols, which are called
3&-2keywords**, in the lambda list.  All such symbols' print names
begin with the character "3&*".  A list of all such symbols is the value of
the symbol 3lambda-list-keywords*. 
.setq &rest page
.setq &key page
	The keywords used here are 3&key*, 3&optional* and 3&rest*.
The way they are used is best explained by means of examples;
the following are typical lambda lists, followed by descriptions
of which parameters are positional, rest or keyword; and required or optional.
.table 7
.item (a b c)
3a*, 3b*, and 3c* are all required and positional.  The function must be
passed three arguments.
.item (a b &optional c)
3a* and 3b* are required, 3c* is optional.  All three are
positional.  The function may be passed either two or three arguments.
.item (&optional a b c)
3a*, 3b*, and 3c* are all optional and positional.  The function may
be passed any number of arguments between zero and three, inclusive.
.item (&rest a)
3a* is a rest parameter.  The function may be passed any number of arguments.
.item (a b &optional c d &rest e)
3a* and 3b* are required positional, 3c* and 3d* are optional
positional, and 3e* is rest.  The function may be passed two or more
arguments.
.item (&key a b)
3a* and 3b* are both required keyword parameters.  A typical
call would look like
.lisp
(foo ':b 69 ':a '(some elements))
.end_lisp
This illustrates that the parameters can be matched in either order.
.item (&key a &optional b)
3a* is required keyword, and 3b* is optional keyword.
The sample call above would be legal for this function also; so would
.lisp
(foo ':a '(some elements))
.end_lisp
which doesn't specify 3b*.
.item (x &optional y &rest z &key a b)
3x* is required positional, 3y* is optional positional,
3z* is rest, and 3a* and 3b* are optional keyword.
One or more arguments are allowed.  One or two arguments specify only
the positional parameters.  Arguments beyond the second specify both
the rest parameter and the keyword parameters, so that
.lisp
(foo 1 2 ':b '(a list))
.end_lisp
specifies 31* for 3x*, 32* for 3y*, 3(:b (a
list))* for 3z*, and 3(a list)* for 3b*.  It does not
specify 3a*.
.item (&rest z &key a b c &allow-other-keys)
3z* is rest, and 3a*, 3b* and 3c* are optional keyword
parameters.  3&allow-other-keys* says that absolutely any keyword
symbols may appear among the arguments; these symbols and the values
that follow them have no effect on the keyword parameters, but do
become part of the value of 3z*.
.item (&rest z &key &allow-other-keys)
This is equivalent to 3(&rest z)*.  So, for that matter, is the
previous example, if the function does not use the values of 3a*,
3b* and 3c*.
.end_table
	In all of the cases above, the 2default-form* for each
optional parameter is 3nil*.  To specify your own default forms,
instead of putting a symbol as the element of a lambda list, put in a
list whose first element is the symbol (the parameter itself) and whose
second element is the default-form.  Only optional parameters may have
default forms; required parameters are never defaulted, and rest
parameters always default to 3nil*.  For example:
.table 7
.item (a &optional (b 3))
The default-form for 3b* is 33*.  3a* is a required parameter, and
so it doesn't have a default form.
.item (&optional (a 'foo) &rest d &key b (c (symeval a)))
3a*'s default-form is 3'foo*, 3b*'s is 3nil*, and 3c*'s is
3(symeval a)*.  Note that if
the function whose lambda list this is were called on no arguments,
3a* would be bound to the symbol 3foo*, and 3c* would be bound
to the binding of the symbol 3foo*; this illustrates the fact
that each variable is bound immediately after its default-form is evaluated,
and so later default-forms may take advantage of earlier parameters
in the lambda list.  3b* and 3d* would be bound to 3nil*.
.end_table
	For a keyword parameter, you normally specify the variable name,
and the keyword proper is usually computed from it.  You can specify the
keyword symbol independently if you need to.  To do this, use a
two-level list instead of a symbol: 3((keyword variable))*.  The top
level of list can also contain an default value and supplied-p variable,
for optional arguments.
.table 7
.item (&key ((foo:a a)) ((foo:b b)))
The function with this argument list will accept two keywords
3foo:a* and 3foo:b*, which will set variables 3a* and 3b*.
.end_table

.cindex supplied-p variable

	Occasionally it is important to know whether a certain optional
parameter was defaulted or not.  You can't tell from just examining its
value, since if the value is the default value, there's no way to tell
whether the caller passed that value explicitly, or whether the caller
didn't pass any value and the parameter was defaulted.  The way to tell
for sure is to put a third element into the list: the third element
should be a variable (a symbol), and that variable is bound to 3nil*
if the parameter was not passed by the caller (and so was defaulted), or
3t* if the parameter was passed.  The new variable is called a "supplied-p"
variable; it is bound to 3t* if the parameter is supplied.
For example:
.table 7
.item (a &optional (b 3 c))
The default-form for 3b* is 33*, and the "supplied-p" variable for 3b*
is 3c*.  If the function is called with one argument, 3b* will be bound
to 33* and 3c* will be bound to 3nil*.  If the function is called
with two arguments, 3b* will be bound to the value that was passed
by the caller (which might be 33*), and 3c* will be bound to 3t*.
.end_table

It is possible to specify a keyword parameter's symbol independently
of its parameter name.  To do this, use 2two* nested lists to
specify the parameter.  The outer list is the one which can contain
the default-form and supplied-p variable, if the parameter is
optional.  The first element of this list, instead of a symbol, is
again a list, whose elements are the keyword symbol and the parameter
variable name.
For example:
.table 7
.item (&key ((:a a)) &optional ((:b b) t))
This is equivalent to 3(&key a &optional (b t)).
.item (&key ((:base base-value)))
This allows a keyword which the user will know under the name
3:base*, without making the parameter shadow the value of
3base*, which is used for printing numbers.
.end_table

	It is also possible to include, in the lambda list, some other
symbols, which are bound to the values of their default-forms upon
entry to the function.  These are 2not* parameters, and they are
never bound to arguments; they just get bound, as if they appeared
in a 3let* form.  (Whether you use these aux-variables or bind the
variables with 3let* is a stylistic decision.)
	To include such symbols, put them after any parameters, preceeded
by the 3&*-keyword 3&aux*.  Examples:
.table 7
.item (a &optional b &rest c &aux d (e 5) (f (cons a e)))
3d*, 3e*, and 3f* are bound, when the function is
called, to 3nil*, 35*, and a cons of the first argument and 5.
.end_table

	Note that aux-variables are bound sequentially rather than
in parallel.

	It is important to realize that the list of arguments to which a
rest-parameter is bound is set up in whatever way is most efficiently
implemented, rather than in the way that is most convenient for the
function receiving the arguments.  It is not guaranteed to be a
"real" list.  Sometimes the rest-args list is stored in the
function-calling stack, and loses its validity when the function
returns.  If a rest-argument is to be returned or made part of permanent
list-structure, it must first be copied (see 3copylist*, page
(copylist-fun)), as you must always assume that it is one of these
special lists.  The system will not detect the error of omitting to copy
a rest-argument; you will simply find that you have a value which seems
to change behind your back.  At other times the rest-args list will be
an argument that was given to 3apply*; therefore it is not safe to
3rplaca* this list as you may modify permanent data structure.  An
attempt to 3rplacd* a rest-args list will be unsafe in this case,
while in the first case it would cause an error, since lists in the stack
are impossible to 3rplacd*.

	There are some other keywords in addition to those mentioned
here.  See (lambda-list-keywords) for a complete list.  You only need
to know about 3&optional* and 3&rest* in order to understand this
manual.

	Lambda lists provide "positional" arguments: the meaning of an
argument comes from its position in the lambda list.  For example, the
first argument to 3cons* is the object that will be the 3car* of the new
cons.  Sometimes it is desirable to use "keyword" arguments, in which
the meaning of an argument comes from a "keyword" symbol that tells the
callee which argument this is.  While lambda lists do not provide
keyword arguments directly, there is a convention for functions that
want arguments passed to them in the keyword fashion.  The convention is
that the function takes a rest-argument, whose value is a list of
alternating keyword symbols and argument values.  If 3cons* were
written as a keyword-style function, then instead of saying
.lisp
(cons 4 (foo))
.end_lisp
you could say either of
.lisp
(cons ':car 4 ':cdr (foo))
1or*
(cons ':cdr (foo) ':car 4)
.end_lisp
assuming the keyword symbols were 3:car* and 3:cdr*.  Keyword symbols
are always in the keyword package,
and so their printed representations always start with a colon; the reason
for this is given in chapter (package-chapter).

This use of keyword arguments is only a convention; it is not built into
the function-calling mechanism of the language.  Your function must
contain Lisp programming to take apart the rest parameter and make sense
of the keywords and values.  The special form 3keyword-extract* (see
(keyword-extract-fun)) may be useful for this.

.section "Some Functions and Special Forms"

This section describes some functions and special forms.  Some are parts
of the evaluator, or closely related to it.  Some have to do
specifically with issues discussed above such as keyword arguments.
Some are just fundamental Lisp forms that are very important.

.defun eval x
3(eval 2x*)* evaluates 2x*, and returns the result.
.lisp
.exdent 96 Example:
(setq x 43 foo 'bar)
(eval (list 'cons x 'foo))
    => (43 . bar)
.end_lisp
	It is unusual to explicitly call 3eval*, since usually
evaluation is done implicitly.  If you are writing a simple Lisp program and
explicitly calling 3eval*, you are probably doing something wrong.
3eval* is primarily useful in programs which deal with Lisp itself,
rather than programs about knowledge or mathematics or games.
	Also, if you are only interested in getting at the value of a
symbol (that is, the contents of the symbol's value cell), then you
should use the primitive function 3symeval* (see (symeval-fun)).
	Note: the actual name of the compiled code for 3eval* is "3si:*eval*";
this is because use of the 2evalhook* feature binds the function cell of 3eval*.
If you don't understand this, you can safely ignore it.
'cindex "evalhook"
	Note: unlike Maclisp, 3eval* never takes a second argument; there
are no "binding context pointers" in Zetalisp.
They are replaced by Closures (see (closure)).
.end_defun

.defun apply f arglist
3(apply 2f* 2arglist*)* applies the function 2f* to the list of
arguments 2arglist*.  2arglist* should be a list; 2f* can be any function.
.lisp
.exdent 96 Examples:
(setq fred '+) (apply fred '(1 2)) => 3
(setq fred '-) (apply fred '(1 2)) => -1
(apply 'cons '((+ 2 3) 4)) =>
	((+ 2 3) . 4)	2not* (5 . 4)
.end_lisp
	Of course, 2arglist* may be 3nil*.
	Note: unlike Maclisp, 3apply* never takes a third argument; there
are no "binding context pointers" in Zetalisp.

	Compare 3apply* with 3funcall* and 3eval*.
.end_defun

.defun funcall f &rest args
3(funcall 2f* 2a1* 2a2* ... 2an*)* applies the
function 2f* to the arguments 2a1*, 2a2*, ..., 2an*.
2f* may not
be a special form nor a macro; this would not be meaningful.
.lisp
.exdent 96 Example:
(cons 1 2) => (1 . 2)
(setq cons 'plus)
(funcall cons 1 2) => 3
.end_lisp
This shows that the use of the symbol 3cons* as the name of a function
and the use of that symbol as the name of a variable do not interact.
The 3cons* form invokes the function named 3cons*.
The 3funcall* form evaluates the variable and gets the symbol 3plus*,
which is the name of a different function.
.end_defun

.defun lexpr-funcall f &rest args
3lexpr-funcall* is like a cross between 3apply* and 3funcall*.
3(lexpr-funcall 2f* 2a1* 2a2* ... 2an* 2l*)* applies the
function 2f*
to the arguments 2a1* through 2an* followed by the elements of
the list 2l*.  Note that since it treats its last argument specially,
3lexpr-funcall* requires at least two arguments.
.lisp
.exdent 96 Examples:
(lexpr-funcall 'plus 1 1 1 '(1 1 1)) => 6

(defun report-error (&rest args)
   (lexpr-funcall (function format) error-output args))
.end_lisp

3lexpr-funcall* with two arguments does the same thing as 3apply*.
.end_defun

Note:  the Maclisp functions 3subrcall*, 3lsubrcall*, and 3arraycall*
are not needed on the Lisp Machine; 3funcall* is just as efficient.
3arraycall* is provided for compatibility; it ignores its first
subform (the Maclisp array type) and is otherwise identical to 3aref*.
3subrcall* and 3lsubrcall* are not provided.
'findex "subrcall"
'findex "lsubrcall"
.c 'findex "arraycall"  -- commented out since it does exist after all

.defun call function &rest argument-specifications
3call* offers a very general way of controlling what arguments you
pass to a function.  You can provide either individual arguments a la
3funcall* or lists of arguments a la 3apply*, in any order.  In
addition, you can make some of the arguments 2optional*.  If the
function is not prepared to accept all the arguments you specify, no
error occurs if the excess arguments are optional ones.  Instead, the
excess arguments are simply not passed to the function.

The 2argument-specs* are alternating keywords (or lists of keywords)
and values.  Each keyword or list of keywords says what to do with the
value that follows.  If a value happens to require no keywords,
provide 3()* as a list of keywords for it.

Two keywords are presently defined: 3:optional* and 3:spread*.
3:spread* says that the following value is a list of arguments.
Otherwise it is a single argument.  3:optional* says that all the
following arguments are optional.  It is not necessary to specify
3:optional* with all the following 2argument-specs*, because it is
sticky.

Example:
.lisp
(call #'foo () x ':spread y '(:optional :spread) z () w)
.end_lisp
The arguments passed to 3foo* are the value of 3x*, the
elements of the value of 3y*, the elements of the value of
3z*, and the value of 3w*.  The function 3foo* must be
prepared to accept all the arguments which come from 3x* and
3y*, but if it does not want the rest, they are ignored.
.end_defun

.defspec quote object
'cindex "quote"
3(quote 2x*)* simply returns 2x*.  It is useful specifically
because 2x* is not evaluated; the 3quote* is how you make a form
that returns an arbitrary Lisp object.  3quote* is used to include
constants in a form.
.lisp
.exdent 96 Examples:
(quote x) => x
(setq x (quote (some list)))   x => (some list)
.end_lisp
	Since 3quote* is so useful but somewhat cumbersome to type, the reader normally
converts any form preceded by a single quote (3'*) character into a 3quote* form.
.lisp
1For example,*
(setq x '(some list))
1is converted by read into*
(setq x (quote (some list)))
.end_lisp
.end_defspec

.defspec function f
This means different things depending on whether 2f* is a function
or the name of a function.  (Note that in neither case is 2f* evaluated.)
The name of a function is a symbol or a function-spec list
(see (function-spec)).  A function is typically a list whose car
is the symbol 3lambda*, however there are several other kinds
of functions available (see (kinds-of-functions)).

If you want to pass an anonymous function as an argument to a function,
you could just use 3quote*; for example:
.lisp
(mapc (quote (lambda (x) (car x))) some-list)
.end_lisp
This works fine as far as the evaluator is concerned.  However, the
compiler cannot tell that the first argument is going to be used as a
function; for all it knows, 3mapc* will treat its first argument as a
piece of list structure, asking for its 3car* and 3cdr* and so forth.  So
the compiler cannot compile the function; it must pass the
lambda-expression unmodified.  This means that the function will not get
compiled, which will make it execute more slowly than it might
otherwise.

The 3function* special form is one way to tell the compiler that
it can go ahead and compile the lambda-expression.  You just use
the symbol 3function* instead of 3quote*:
.lisp
(mapc (function (lambda (x) (car x))) some-list)
.end_lisp
This will cause the compiler to generate code such that 3mapc* will be
passed a compiled-code object as its first argument.

That's what the compiler does with a 3function* special form whose
subform 2f* is a function.  The evaluator, when given such a form,
just returns 2f*; that is, it treats 3function* just like 3quote*.

To ease typing, the reader converts 3#'2thing** into 3(function 2thing*)*.
So 3#'* is similar to 3'* except that it produces a
3function* form instead of a 3quote* form.  So the above form
could be written as 
.lisp
(mapc #'(lambda (x) (car x)) some-list)
.end_lisp

If 2f* is not a function but the name of a function
(typically a symbol, but in general any kind of function spec), then
3function* returns the definition of 2f*; it is like 3fdefinition*
except that it is a special form instead of a function, and so
.lisp
(function fred)  1is like*  (fdefinition 'fred)
                 1which is like* (fsymeval 'fred)
.end_lisp
since 3fred* is a symbol.
3function* is the same for the compiler and the interpreter when
2f* is the name of a function.

Another way of explaining 3function* is that it causes 2f* to be
treated the same way as it would as the car of a form.  Evaluating
the form 3(2f* 2arg1* 2arg2*...)* uses the function definition
of 2f* if it is a symbol, and otherwise expects 2f* to be a list
which is a lambda-expression.  Note that the car of a form may not be
a non-symbol function spec, to avoid difficult-to-read code.  This can be
written as
.lisp
(funcall (function 2spec*) 2args*...)
.end_lisp

You should be careful about whether you use 3#'* or 3'*.  Suppose
you have a program with a variable 3x* whose value is assumed to
contain a function that gets called on some arguments.  If you want that
variable to be the 3car* function, there are two things you could say:
.lisp
(setq x 'car)
1or*
(setq x #'car)
.end_lisp
The former causes the value of 3x* to be the symbol 3car*, whereas
the latter causes the value of 3x* to be the function object found in
the function cell of 3car*.  When the time comes to call the function
(the program does 3(funcall x ...)*), either of these two will work
(because if you use a symbol as a function, the contents of the symbol's
function cell is used as the function, as explained in the beginning of
this chapter).  The former case is a bit slower, because the function
call has to indirect through the symbol, but it allows the function
to be redefined, traced (see (trace-fun)), or advised (see (advise-fun)).
The latter case, while faster, picks up the function definition out of
the symbol 3car* and does not see any later changes to it.

The other way to tell the compiler that an argument that is a lambda
expression should be compiled is for the function that takes the
function as an argument to use the 3&functional* keyword in its
lambda list; see (lambda-list-keywords).  The basic system functions that
take functions as arguments, such as 3map* and 3sort*, have
this 3&functional* keyword and hence quoted lambda-expressions
given to them will be recognized as functions by the compiler.

In fact, 3mapc* uses 3&functional* and so the example given above
is bogus; in the particular case of the first argument to the function 3mapc*,
3quote* and 3function* are synonymous.  It is good style to use 3function*
(or 3#'*) anyway, to make the intent of the program completely clear.
.end_defspec

.defun false
Takes no arguments and returns 3nil*.
.end_defun

.defun true
Takes no arguments and returns 3t*.
.end_defun

.defun ignore &rest ignore
Takes any number of arguments and returns 3nil*.  This is often useful
as a "dummy" function; if you are calling a function that takes a function
as an argument, and you want to pass one that doesn't do anything and
won't mind being called with any argument pattern, use this.
.end_defun

.defspec comment
3comment* ignores its form and returns the symbol 3comment*.
.lisp
.exdent 96 Example:
(defun foo (x)
    (cond ((null x) 0)
          (t (comment x has something in it)
             (1+ (foo (cdr x))))))
.end_lisp
	Usually it is preferable to comment code using the
semicolon-macro feature of the standard input syntax.  This allows the
user to add comments to his code which are ignored by the lisp reader. 
.lisp
.exdent 96 Example:
(defun foo (x)
    (cond ((null x) 0)
          (t (1+ (foo (cdr x))))     ;x has something in it
      ))
.end_lisp

A problem with such comments is that they are discarded when the form
is read into Lisp.  If the function is read into Lisp, modified, and printed
out again, the comment will be lost.  However, this style of operation is hardly
ever used; usually the source of a function is kept in an editor buffer and
any changes are made to the buffer, rather than the actual list structure
of the function.  Thus, this is not a real problem.
.end_defspec

.defspec progn body...
The 2body* forms are evaluated in order from left to right and the value
of the last one is returned.
3progn* is the primitive control structure construct for "compound
statements".  Although lambda-expressions, 3cond* forms, 3do* forms, and
many other control structure forms use 3progn* implicitly, that is,
they allow multiple forms in their bodies, there are occasions when
one needs to evaluate a number of forms for their side-effects and
make them appear to be a single form.
.lisp
.exdent 96 Example:
(foo (cdr a)
     (progn (setq b (extract frob))
	    (car b))
     (cadr b))
.end_lisp

(When 2form1* is 3'compile*, the 3progn* form has a special meaning
to the compiler.  This is discussed on (progn-quote-compile-discussion).)
.end_defspec

.defspec prog1 first-form body...
3prog1* is similar to 3progn*, but it returns the value of its 2first* form rather
than its last.
It is most commonly used to evaluate an expression with side effects, and return
a value which must be computed 2before* the side effects happen.
.lisp
.exdent 96 Example:
(setq x (prog1 y (setq y x)))
.end_lisp
interchanges the values of the variables 2x* and 2y*.  3prog1* never
returns multiple values.
.end_defspec

.defspec prog2 first-form second-form body...
3prog2* is similar to 3progn* and 3prog1*, but it returns its
2second* form.  It is included largely for compatibility with old programs.
.end_defspec

See also 3bind* ((bind-fun)), which is a
subprimitive that gives you maximal control over binding.

The following three functions (3arg*, 3setarg*, and 3listify*)
exist only for compatibility with Maclisp 2lexprs*.  To write functions
that can accept variable numbers of arguments, use the 3&optional* and
3&rest* keywords (see (function-section)).
'cindex "lexpr"

.defun arg x
3(arg nil)*, when evaluated during the application of
a lexpr, gives the number of arguments supplied to that
lexpr.
This is primarily a debugging aid, since lexprs also receive their number of arguments
as the value of their 3lambda*-variable.

3(arg 2i*)*, when evaluated during the application of a lexpr, gives the value of the
2i*'th argument to the lexpr.  2i* must be a fixnum in this case. It is an error if 2i* is less than 1 or greater than the number
of arguments supplied to the lexpr.
.lisp
.exdent 96 Example:
(defun foo nargs            ;1define a lexpr *foo.
    (print (arg 2))         ;1print the second argument.*
    (+ (arg 1)              ;1return the sum of the first*
       (arg (- nargs 1))))  ;1and next to last arguments.*
.end_lisp
.end_defun

.defun setarg i x
3setarg* is used only during the application of a lexpr.
3(setarg 2i x*)* sets the
lexpr's 2i*'th argument to 2x*.
2i* must be greater than zero
and not greater than the number of arguments passed to the lexpr.
After 3(setarg 2i x*)* has been done, 3(arg 2i*)* will return 2x*.
.end_defun

.defun listify n
3(listify 2n*)* manufactures a list of 2n* of the
arguments of a lexpr.  With a positive argument 2n*, it returns a
list of the first 2n* arguments of the lexpr.  With a negative
argument 2n*, it returns a list of the last 3(abs 2n*)*
arguments of the lexpr.  Basically, it works as if defined as follows: 
.lisp
(defun listify (n)
     (cond ((minusp n)
	    (listify1 (arg nil) (+ (arg nil) n 1)))
	   (t
	    (listify1 n 1)) ))

(defun listify1 (n m)      ;1 auxiliary function.*
     (do ((i n (1- i))
	  (result nil (cons (arg i) result)))
	 ((< i m) result) ))
.end_lisp
.end_defun

.section Multiple Values
.cindex multiple values
.cindex returning multiple values
.setq multiple-value section-page

The Lisp Machine includes a facility by which the evaluation of a form
can produce more than one value.  When a function needs to return more
than one result to its caller, multiple values are a cleaner way of
doing this than returning a list of the values or 3setq*'ing special
variables to the extra values.  In most Lisp function calls, multiple
values are not used.  Special syntax is required both to 2produce*
multiple values and to 2receive* them.

The primitive for producing multiple values is 3values*, which takes
any number of arguments and returns that many values.  If the last form
in the body of a function is a 3values* with three arguments, then
a call to that function will return three values.
The other primitive for producing multiple values is 3return*, which when
given more than one argument returns all its arguments as the values of
the 3prog* or 3do* from which it is returning.  The variant
3return-from* also can produce multiple values.  Many system functions
produce multiple values, but they all do it via the 3values*
and 3return* primitives.

The special forms for receiving multiple values are 3multiple-value*,
3multiple-value-bind*, and 3multiple-value-list*.  These consist of
a form and an indication of where to put the values returned by that form.
With the first two of these, the caller requests a certain number of
returned values.  If fewer values are returned than the number requested,
then it is exactly as if the rest of the values were present and had the
value 3nil*.  If too many values are returned, the rest of the values
are ignored.  This has the advantage that you don't have to pay attention
to extra values if you don't care about them, but it has the disadvantage
that error-checking similar to that done for function calling is not present.

.defun values &rest args
Returns multiple values, its arguments.  This is the primitive
function for producing multiple values.  It is legal to call 3values* with
no arguments; it returns no values in that case.
.end_defun

.defun values-list list
Returns multiple values, the elements of the 2list*.  3(values-list '(a b c))*
is the same as 3(values 'a 'b 'c)*.
2list* may be 3nil*, the empty list, which causes no values to be returned.
.end_defun

3return* and its variants can only be used within the 3do* and
3prog* special forms and their variants, and so they are explained on
(return-fun).

.defspec multiple-value (variable...) form
3multiple-value* is a special
form used for calling a function which
is expected to return more than one value.
2form* is evaluated, and the 2variables*
are 2set* (not lambda-bound) to the values returned by 2form*.  If more values
are returned than there are variables, then the extra values
are ignored.  If there are more variables than values returned,
extra values of 3nil* are supplied.  If 3nil* appears in the 2var-list*,
then the corresponding value is ignored (you can't use 3nil* as a variable.)
.lisp
.exdent 96 Example:
(multiple-value (symbol already-there-p)
	(intern "goo"))
.end_lisp
In addition to its first value (the symbol), 3intern* returns a second
value, which is 3t* if the symbol returned as the first value was
already interned, or else 3nil* if 3intern* had to create it.  So if
the symbol 3goo* was already known, the variable 3already-there-p*
will be set to 3t*, otherwise it will be set to 3nil*.  The third value
returned by 3intern* will be ignored.

3multiple-value* is usually used for effect rather than for value; however,
its value is defined to be the first of the values returned by 2form*.
.end_defspec

.defspec multiple-value-bind (variable...) form body...
This is similar to 3multiple-value*, but locally binds the variables which
receive the values, rather than setting them, and has a body--a set of forms
which are evaluated with these local bindings in effect.
First 2form* is evaluated.  Then the 2variables* are
bound to the values returned by 2form*.  Then the 2body* forms
are evaluated sequentially, the bindings are undone, and the result
of the last 2body* form is returned.
.end_defspec

.defspec multiple-value-list form
3multiple-value-list* evaluates 2form*, and returns a list of
the values it returned.  This is useful for when you don't know how many values
to expect.
.lisp
.exdent 96 Example:
(setq a (multiple-value-list (intern "goo")))
a => (goo nil #<Package User>)
.end_lisp
This is similar to the example of 3multiple-value* above; 3a* will be set
to a list of three elements, the three values returned by 3intern*.
.end_defspec

Due to the syntactic structure of Lisp, it is often the case that the value
of a certain form is the value of a sub-form of it.  For example, the
value of a 3cond* is the value of the last form in the selected clause.
In most such cases, if the sub-form produces multiple values, the original
form will also produce all of those values.  This 2passing-back* of
multiple values of course has no effect unless eventually one of the
special forms for receiving multiple values is reached.
The exact rule governing passing-back of multiple values is as follows:

If 2X* is a form, and 2Y* is a sub-form of 2X*, then if the value
of 2Y* is unconditionally returned as the value of 2X*, with no
intervening computation, then all the multiple values returned by 2Y*
are returned by 2X*.  In all other cases, multiple values or only
single values may be returned at the discretion of the implementation;
users should not depend on whatever way it happens to work, as it
may change in the future or in other implementations.  The reason we don't guarantee
non-transmission of multiple values is because such a guarantee would
not be very useful and the efficiency cost of enforcing it would be
high.  Even 3setq*'ing a variable to the result of a form, then
returning the value of that variable might be made to pass multiple
values by an optimizing compiler which realized that the 3setq*ing of
the variable was unnecessary.

Note that use of a form as an argument to a function never receives
multiple values from that form.  That is, if the form 3(foo (bar))*
is evaluated and the call to 3bar* returns many values, 3foo* will
still only be called on one argument (namely, the first value returned),
rather than being called on all the values returned.  We choose not to
generate several separate arguments from the several values, because
this would make the source code obscure; it would not be syntactically
obvious that a single form does not correspond to a single argument.
Instead, the first value of a form is used as the argument and the
remaining values are discarded.  Receiving of multiple values is done
only with the above-mentioned special forms.

For clarity, descriptions of the interaction of several common special
forms with multiple values follow.  This can all be deduced from the
rule given above.  Note well that when it says that multiple values
are not returned, it really means that they may or may not be returned,
and you should not write any programs that depend on which way it works.

The body of a 3defun* or a 3lambda*, and variations such as the
body of a function, the body of a 3let*, etc., pass back multiple
values from the last form in the body.

3eval*, 3apply*, 3funcall*, and 3lexpr-funcall*
pass back multiple values from the function called.

3progn* passes back multiple values from its last form.  3progv* and
3progw* do so also.  3prog1* and 3prog2*, however, do not pass
back multiple values.

Multiple values are passed back from the last subform of an 3and* or 3or* form,
but not from previous forms since the return is conditional.  Remember
that multiple values are only passed back when the value of a sub-form
is unconditionally returned from the containing form.  For example,
consider the form 3(or (foo) (bar))*.  If 3foo* returns a non-3nil*
first value, then only that value will be returned as the value of the
form.  But if it returns 3nil* (as its first value), then 3or*
returns whatever values the call to 3bar* returns.

3cond* passes back multiple values from the last form in the
selected clause, but not if the clause is only one long (i.e. the
returned value is the value of the predicate) since the return is
conditional.  This rule applies even to the last clause, where the return
is not really conditional (the implementation is allowed to pass
or not to pass multiple values in this case, and so you shouldn't
depend on what it does).  3t* should be used as the predicate of the
last clause if multiple values are desired, to make it clear to the
compiler (and any human readers of the code!) that the return is not
conditional.

The variants of 3cond* such as 3if*, 3select*, 3selectq*, and
3dispatch* pass back multiple values from the last form in the
selected clause.

The number of values returned by 3prog* depends on the 3return* form
used to return from the 3prog*.  (If a 3prog* drops off the end it
just returns a single 3nil*.)  If 3return* is given two or more
subforms, then 3prog* will return as many values as the 3return* has
subforms.  However, if the 3return* has only one subform, then the
3prog* will return all of the values returned by that one subform.

3do* behaves like 3prog* with respect to 3return*.
All the values of the last 2exit-form* are returned.

3unwind-protect* passes back multiple values from its protected form.

3*catch* does not pass back multiple values from the last form
in its body, because it is defined to return its
own second value (see (*catch-fun)) to tell you whether the 3*catch*
form was exited normally or abnormally.  This is sometimes inconvenient
when you want to propagate back multiple values but you also want to wrap
a 3*catch* around some forms.  Usually people get around this problem
by enclosing the 3*catch* in a 3prog* and using 3return* to pass
out the multiple values, 3return*ing through the 3*catch*.  This is
inelegant, but we don't know anything that's much better.
