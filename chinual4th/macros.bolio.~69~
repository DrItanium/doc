.c This file is part of the Lisp Machine manual.	-*-Bolio-*-
.c Macros: introduction, examples, DEFMACRO, backquote.
.c Note: there are still some sections to be written; see end of the file.

.chapter "Macros"
.setq macro section-page
.setq macros-chapter chapter-number
.cindex macros
.c Macros!!!!!!!

.section "Introduction to Macros"

If 3eval* is handed a list whose car is a symbol, then 3eval*
inspects the definition of the symbol to find out what to do.  If the
definition is a cons, and the car of the cons is the symbol
3macro*, then the definition (i.e. that cons) is called a 2macro*.
The cdr of the cons should be a function of one argument.
3eval* applies the function to the form it was originally given,
takes whatever is returned, and evaluates that in lieu of the
original form.

	Here is a simple example.  Suppose the definition of the symbol 3first* is
.lisp
(macro lambda (x) 
         (list 'car (cadr x)))
.end_lisp
This thing is a macro: it is a cons whose car is the symbol
3macro*.  What happens if we try to evaluate a form 3(first '(a b
c))*?  Well, 3eval* sees that it has a list whose car is a symbol
(namely, 3first*), so it looks at the definition of the symbol and
sees that it is a cons whose car is 3macro*; the definition is
a macro.

3eval* takes the cdr of the cons, which is supposed to be the
macro's 2expander function*, and calls it providing as an argument the
original form that 3eval* was handed.  So it calls
3(lambda (x) (list 'car (cadr x)))* with argument 3(first '(a b c))*.
Whatever this returns is the 2expansion* of the macro call.  It will
be evaluated in place of the original form.

In this case, 3x* is bound to 3(first '(a b c))*, 3(cadr x)*
evaluates to 3'(a b c)*, and 3(list 'car (cadr x))* evaluates to
3(car '(a b c))*, which is the expansion.  3eval* now evaluates the
expansion.  3(car '(a b c))* returns 3a*, and so the result is that
3(first '(a b c))* returns 3a*.

	What have we done?  We have defined a macro called 3first*.  What
the macro does is to 2translate* the form to some other form.  Our
translation is very simple--it just translates forms that look like
3(first 2x*)* into 3(car 2x*)*, for any form 2x*.
We can do much more
interesting things with macros, but first we will show how
to define a macro.

.defspec macro
The primitive special form for defining macros is 3macro*.
A macro definition looks like this:
.lisp
(macro 2name* (2arg*)
    2body*)
.end_lisp
2name* can be any function spec.  2arg* must be a variable.  2body* is
a sequence of Lisp forms that expand the macro; the last form should return
the expansion.
.end_defspec

To define our 3first* macro, we would say
.lisp
(macro first (x)
    (list 'car (cadr x)))
.end_lisp

	Here are some more simple examples of macros.  Suppose we want
any form that looks like 3(addone 2x*)* to be translated into
3(plus 1 2x*)*.  To define a macro to do this we would say
.lisp
(macro addone (x)
   (list 'plus '1 (cadr x)))
.end_lisp

	Now say we wanted a macro which would translate 3(increment 2x*)*
into 3(setq 2x* (1+ 2x*)*.  This would be:
.lisp
(macro increment (x)
    (list 'setq (cadr x) (list '1+ (cadr x))))
.end_lisp
Of course, this macro is of limited usefulness.  The reason is that the
form in the 2cadr* of the 3increment* form had better be a symbol.
If you tried 3(increment (car x))*, it would be translated into
3(setq (car x) (1+ (car x)))*, and 3setq* would complain.
(If you're interested in how to fix this problem, see 3setf* ((setf-fun));
but this is irrelevant to how macros work.)

	You can see from this discussion that macros are very different
from functions.  A function would not be able to tell what kind of
subforms are around in a call to itself; they get evaluated before the
function ever sees them.  However, a macro gets to look at the whole
form and see just what is going on there.  Macros are 2not* functions;
if 3first* is defined as a macro, it is not meaningful to apply
3first* to arguments.  A macro does not take arguments at all; its
expander function takes a 2Lisp form* and turns it into another 2Lisp
form*.

	The purpose of functions is to 2compute*; the purpose of
macros is to 2translate*.  Macros are used for a variety of purposes, the
most common being extensions to the Lisp language.  For example, Lisp
is powerful enough to express many different control structures, but it
does not provide every control structure anyone might ever possibly
want.  Instead, if a user wants some kind of control structure with a
syntax that is not provided, he can  translate it into some form that
Lisp 2does* know about.

	For example, someone might want a limited iteration construct
which increments a variable by one until it exceeds a limit (like the
FOR statement of the BASIC language).  He might want it to look like
.lisp
(for a 1 100 (print a) (print (* a a)))
.end_lisp
To get this, he could write a macro to translate it into
.lisp
(do a 1 (1+ a) (> a 100) (print a) (print (* a a)))
.end_lisp
A macro to do this could be defined with
.lisp
(macro for (x)
  (cons 'do
	(cons (cadr x)
	      (cons (caddr x)
		    (cons (list '1+ (cadr x))
			  (cons (list '> (cadr x) (cadddr x))
				(cddddr x)))))))
.end_lisp
Now he has defined his own new control structure primitive, and it
will act just as if it were a special form provided by Lisp itself.

.section "Aids for Defining Macros"

	The main problem with the definition for the 3for* macro is
that it is verbose and clumsy.  If it is that hard to write a macro
to do a simple specialized iteration construct, one would wonder how
anyone could write macros of any real sophistication.

	There are two things that make the definition so inelegant.
One is that the programmer must write things like "3(cadr x)*"
and "3(cddddr x)*" to refer to the parts of the form he wants
to do things with.  The other problem is that the long chains of calls
to the 3list* and 3cons* functions are very hard to read.

	Two features are provided to solve these two problems.
The 3defmacro* macro solves the former, and the "backquote" (3`*)
reader macro solves the latter.

.subsection "Defmacro"
.cindex macro-defining macros
.cindex defmacro

	Instead of referring to the parts of our form by "3(cadr x)*"
and such, we would like to give names to the various pieces of the form,
and somehow have the 3(cadr x)* automatically generated.  This is done
by a macro called 3defmacro*.  It is easiest to explain what 3defmacro* does
by showing an example. Here is how you would write the 3for* macro
using 3defmacro*:
.lisp
(defmacro for (var lower upper . body)
  (cons 'do
	(cons var
	      (cons lower
		    (cons (list '1+ var)
			  (cons (list '> var upper)
				body))))))
.end_lisp

	The 3(var lower upper . body)* is a 2pattern* to match against
the body of the form (to be more precise, to match against the cdr
of the argument to the macro's expander function).  If 3defmacro* tries to match the two
lists
.lisp
(var lower upper . body)
1and*
(a 1 100 (print a) (print (* a a)))
.end_lisp
3var* will get bound to the symbol 3a*, 3lower* to the fixnum 31*,
3upper* to the fixnum 3100*, and 3body* to the list
3((print a) (print (* a a)))*.  Then inside the body of the 3defmacro*,
3var, lower, upper,* and 3body* are variables, bound to the matching
parts of the macro form.

.defmac defmacro
3defmacro* is a general purpose macro-defining macro.  A 3defmacro*
form looks like 
.lisp
(defmacro 2name* 2pattern* . 2body*)
.end_lisp
The 2pattern* may be anything made up out of symbols and conses.
It is matched against the body of the macro form; both 2pattern*
and the form are car'ed and cdr'ed identically, and whenever
a non-3nil* symbol is hit in 2pattern*, the symbol is bound to the corresponding
part of the form.  All of the symbols in 2pattern* can be used
as variables within 2body*.  2name* is the name of the macro
to be defined; it can be any function spec (see (function-spec)).
2body* is evaluated with these bindings in effect,
and its result is returned to the evaluator as the expansion of the macro.
.end_defmac

	Note that the pattern need not be a list the way a lambda-list must.
In the above example, the pattern was a "dotted list", since the symbol
3body* was supposed to match the cddddr of the macro form.
If we wanted a new iteration form, like 3for* except that
our example would look like
.lisp
(for a (1 100) (print a) (print (* a a)))
.end_lisp
(just because we thought that was a nicer syntax), then we could
do it merely by modifying the pattern of the 3defmacro* above;
the new pattern would be 3(var (lower upper) . body)*.

	Here is how we would write our other examples using 3defmacro*:
.lisp
(defmacro first (the-list)
    (list 'car the-list))

(defmacro addone (form)
   (list 'plus '1 form))

(defmacro increment (symbol)
   (list 'setq symbol (list '1+ symbol)))
.end_lisp
All of these were very simple macros and have very simple patterns,
but these examples show that we can replace the 3(cadr x)* with a
readable mnemonic name such as 3the-list* or 3symbol*, which
makes the program clearer, and enables documentation facilities such
as the 3arglist* function to describe the syntax of the special form
defined by the macro.

	There is another version of 3defmacro* which defines
displacing macros (see (displacing-macro)).
3defmacro* has other, more complex features; see (defmacro-hair).

.subsection "Backquote"
.setq backquote section-page
.cindex backquote

	Now we deal with the other problem: the long strings of calls to
3cons* and 3list*.  This problem is relieved by introducing some new
characters that are special to the Lisp reader.  Just as the
single-quote character makes it easier to type things of the form
3(quote 2x*)*, so will some more new special characters make it
easier to type forms that create new list structure.  The functionality
provided by these characters is called the 2backquote* facility.

	The backquote facility is used by giving a backquote character
(3`*), followed by a form.  If the form does
not contain any use of the comma character, the backquote acts just
like a single quote: it creates a form which, when evaluated, produces
the form following the backquote.  For example,
.lisp
 '(a b c) => (a b c)
 `(a b c) => (a b c)
.end_lisp
So in the simple cases, backquote is just like the regular single-quote
macro.  The way to get it to do interesting things is to include a
comma somewhere inside of the form following the backquote.
The comma is followed by a form, and that form gets evaluated even
though it is inside the backquote.  For example,
.lisp
(setq b 1)
`(a b c)  => (a b c)
`(a ,b c) => (a 1 c)
`(abc ,(+ b 4) ,(- b 1) (def ,b)) => (abc 5 0 (def 1))
.end_lisp
In other words, backquote quotes everything 2except* things preceeded by
a comma; those things get evaluated.

	A list following a backquote can be thought of as a template for
some new list structure.  The parts of the list that are preceeded by
commas are forms that fill in slots in the template; everything else is
just constant structure that will appear in the result.  This is usually
what you want in the body of a macro; some of the form generated by the macro
is constant, the same thing on every invocation of the macro.  Other parts
are different every time the macro is called, often being functions of
the form that the macro appeared in (the "arguments" of the macro).  The
latter parts are the ones for which you would use the comma.  Several examples
of this sort of use follow.

	When the reader sees the 3`(a ,b c)* it is actually generating
a form such as 3(list 'a b 'c)*.  The actual form generated may use
3list*, 3cons*, 3append*, or whatever might be a good idea; you
should never have to concern yourself with what it actually turns into.
All you need to care about is what it evaluates to.  Actually, it
doesn't use the regular functions 3cons*, 3list*, and so forth, but
uses special ones instead so that the grinder can recognize a form which
was created with the backquote syntax, and print it using backquote so
that it looks like what you typed in.  You should never write any
program that depends on this, anyway, because backquote makes no
guarantees about how it does what it does.  In particular, in some
circumstances it may decide to create constant forms, that will cause
sharing of list structure at run time, or it may decide to create forms
that will create new list structure at run time.
For example, if the readers sees 3`(r . ,nil)*,
it may produce the same thing as 3(cons 'r nil)*, or 3'(r . nil)*.
Be careful that your program does not depend on which of these it does.

	This is generally found to be pretty confusing by most people; the best way
to explain further seems to be with examples.  Here is how we would write our
three simple macros using both the 3defmacro* and backquote facilities.
.lisp
(defmacro first (the-list)
    `(car ,the-list))

(defmacro addone (form)
   `(plus 1 ,form))

(defmacro increment (symbol)
   `(setq ,symbol (1+ ,symbol)))
.end_lisp
To finally demonstrate how easy it is to define macros with these two facilities,
here is the final form of the 3for* macro.
.lisp
(defmacro for (var lower upper . body)
  `(do ,var ,lower (1+ ,var) (> ,var ,upper) . ,body))
.end_lisp
Look at how much simpler that is than the original definition.  Also,
look how closely it resembles the code it is producing.  The functionality
of the 3for* really stands right out when written this way.

	If a comma inside a backquote form is followed by an "atsign"
character (3@*), it has a special meaning.  The "3,@*" should
be followed by a form whose value is a 2list*; then each of the elements
of the list is put into the list being created by the backquote.  In other
words, instead of generating a call to the 3cons* function, backquote
generates a call to 3append*.  For example, if 3a* is bound to
3(x y z)*, then 3`(1 ,a 2)* would evaluate to 3(1 (x y z) 2)*,
but 3`(1 ,@a 2)* would evaluate to 3(1 x y z 2)*.

	Here is an example of a macro definition that uses the "3,@*"
construction.  Suppose you wanted to extend Lisp by adding a kind of
special form called 3repeat-forever*, which evaluates all of its
subforms repeatedly.  One way to implement this would be to expand
.lisp
(repeat-forever 2form1* 2form2* 2form3*)
.end_lisp
into
.lisp
(prog ()
    a 2form1*
      2form2*
      2form3*
      (go a))
.end_lisp
	You could define the macro by
.lisp
(defmacro repeat-forever body
       `(prog ()
            a ,@body
              (go a)))
.end_lisp

A similar construct is "3,.*" (comma, dot).  This means the same thing
as "3,@*" except that the list which is the value of the following form
may be freely smashed; backquote uses 3nconc* rather than 3append*.
This should of course be used with caution.

Backquote does not make any guarantees about what parts of the structure it
shares and what parts it copies.  You should not do destructive operations
such as 3nconc* on the results of backquote forms such as
.lisp
`(,a b c d)
.end_lisp
since backquote might choose to implement this as
.lisp
(cons a '(b c d))
.end_lisp
and 3nconc* would smash the constant.  On the other hand, it would be
safe to 3nconc* the result of
.lisp
`(a b ,c ,d)
.end_lisp
since there is nothing this could expand into that does not involve
making a new list, such as
.lisp
(list 'a 'b c d)
.end_lisp

Backquote of course guarantees not to do any destructive operations
(3rplaca*, 3rplacd*, 3nconc*) on the components of the
structure it builds, unless the "3,.*" syntax is used.

	Advanced macro writers sometimes write "macro-defining macros":
forms which expand into forms which, when evaluated, define macros.  In
such macros it is often useful to use nested backquote constructs.  The
following example illustrates the use of nested backquotes in the
writing of macro-defining macros.

	This example is a very simple version of 3defstruct* (see (defstruct-fun)).
You should first understand the basic description of 3defstruct* before
proceeding with this example.  The 3defstruct* below does not accept
any options, and only allows the simplest kind of items; that is, it only
allows forms like
.lisp
(defstruct (2name*)
     2item1*
     2item2*
     2item3*
     2item4*
     ...)
.end_lisp
	We would like this form to expand into
.lisp
(progn 'compile
 (defmacro 2item1* (x)
      `(aref ,x 0))
 (defmacro 2item2* (x)
      `(aref ,x 1))
 (defmacro 2item3* (x)
      `(aref ,x 2))
 (defmacro 2item4* (x)
      `(aref ,x 3))
 ...)
.end_lisp

(The meaning of the 3(progn 'compile ...)* is discussed on
(progn-quote-compile-page).) Here is the macro to perform the
expansion:
.lisp
(defmacro defstruct ((name) . items)
     (do ((item-list items (cdr item-list))
	  (ans nil)
	  (i 0 (1+ i)))
	 ((null item-list)
          `(progn 'compile . ,(nreverse ans)))
       (setq ans
	     (cons `(defmacro ,(car item-list) (x)
			   `(aref ,x ,',i))
		   ans))))
.end_lisp
	The interesting part of this definition is the body of
the (inner) 3defmacro* form:
.lisp
`(aref ,x ,',i)
.end_lisp
Instead of using this backquote construction, we could have written
.lisp
(list 'aref x ,i)
.end_lisp
That is, the "3,',*"
acts like a comma which matches the outer backquote, while
the "3,*" preceeding the "3x*" matches with the inner
backquote.  Thus, the symbol 3i* is evaluated when the
3defstruct* form is expanded, whereas the symbol 3x* is
evaluated when the accessor macros are expanded.

	Backquote can be useful in situations other than the writing
of macros.  Whenever there is a piece of list structure to be consed
up, most of which is constant, the use of backquote can make the
program considerably clearer.

.section Substitutable Functions
.cindex subst
.cindex substitutable function

A substitutable function is a function which is open coded by the
compiler.  It is like any other function when applied, but it can be
expanded instead, and in that regard resembles a macro.

.defspec defsubst
3defsubst* is used for defining substitutable functions.  It is used just
like 3defun*.
.lisp
(defsubst 2name* 2lambda-list* . 2body*)
.end_lisp
and does almost the same thing.  It defines a function which executes
identically to the one which a similar call to 3defun* would define.  The
difference comes when a function which 2calls* this one is compiled.  Then,
the call will be open-coded by substituting the substitutable function's
definition into the code being compiled.  The function itself
looks like 3(named-subst 2name* 2lambda-list* . 2body*)*.  Such a function
is called a 3subst*.  For example, if
we define
.lisp
(defsubst square (x) (* x x))

(defun foo (a b) (square (+ a b)))
.end_lisp
then if 3foo* is used interpreted, 3square* will work just as if it had
been defined by 3defun*.  If 3foo* is compiled, however, the squaring
will be substituted into it and it will compile just like
.lisp
(defun foo (a b) (* (+ a b) (+ a b)))
.end_lisp
3square*'s definition would be
.lisp
(named-subst square (x) (* x x))
.end_lisp
(The internal formats of 3subst*s and 3named-subst*s are explained in (subst).)

A similar 3square* could be defined as a macro, with
.lisp
(defmacro square (x) `(* ,x ,x))
.end_lisp
In general, anything that is implemented as a 3subst* can be re-implemented
as a macro, just by changing the 3defsubst* to a 3defmacro* and putting
in the appropriate backquote and commas.  The disadvantage of macros
is that they are not functions, and so cannot be applied to arguments.
Their advantage is that they can do much more powerful things than
3subst*s can.  This is also a disadvantage since macros provide more
ways to get into trouble.  If something can be implemented either as a macro
or as a 3subst*, it is generally better to make it a 3subst*.

The 2lambda-list* of a 3subst* may contain 3&optional* and
3&rest*, but no other lambda-list keywords.  If there is a
rest-argument, it is replaced in the body with an explicit call to
3list*:
.lisp
(defsubst append-to-foo (&rest args) (setq foo (append args foo)))
(append-to-foo x y z)
.end_lisp
expands to
.lisp
(setq foo (append (list x y z) foo))
.end_lisp

Rest arguments in 3subst*s are most useful with
3lexpr-funcall*, because of an optimization that is done:
.lisp
(defsubst xhack (&rest indices) (lexpr-funcall 'xfun xarg1 indices))
(xhack a (car b))
.end_lisp
is equivalent to
.lisp
(xfun xarg1 a (car b))
.end_lisp
If 3xfun* is itself a 3subst*, it will be expanded in turn.

You will notice that the substitution performed is very simple and takes no care
about the possibility of computing an argument twice when it really ought to be
computed once.  
For instance, in the current implementation, the functions
.lisp
(defsubst reverse-cons (x y) (cons y x))
(defsubst in-order (a b c) (and (< a b) (< b c)))
.end_lisp
would present problems.  When compiled, because of the substitution
a call to 3reverse-cons* would evaluate its arguments in the
wrong order, and a call to 3in-order* could evaluate its second
argument twice.  This will be fixed at some point in the future,
but for now the writer of 3defsubst*'s must be cautious.
Also all occurrences of the argument names in the body are replaced
with the argument forms, wherever they appear.  Thus an argument name
should not be used in the body for anything else, such as a function
name or a symbol in a constant.

As with 3defun*, 2name* can be any function spec.
.end_defspec


.section Hints to Macro Writers

There are many useful techniques for writing macros.  Over the years,
Lisp programmers have discovered techniques that most programmers find
useful, and have identified pitfalls that must be avoided.  This
section discusses some of these techniques, and illustrates them with
examples.

The most important thing to keep in mind as you learn to write macros
is that the first thing you should do is figure out what the macro form
is supposed to expand into, and only then should you start to actually
write the code of the macro.  If you have a firm grasp of what the
generated Lisp program is supposed to look like, from the start, you
will find the macro much easier to write.

In general any macro that can be written as a substitutable
function (see (defsubst-fun)) should be written as one, not as a macro,
for several reasons: substitutable functions are easier to write and to
read; they can be passed as functional arguments (for example, you can
pass them to 3mapcar*); and there are some subtleties that can occur
in macro definitions that need not be worried about in substitutable
functions.  A macro can be a substitutable function only if it has
exactly the semantics of a function, rather than a special form.  The
macros we will see in this section are not semantically like functions;
they must be written as macros.

.subsection Name Conflicts

One of the most common errors in writing macros is best illustrated by
example.  Suppose we wanted to write 3dolist* (see (dolist-fun)) as
a macro that expanded into a 3do* (see (do-fun)).  The first step,
as always, is to figure out what the expansion should look like.  Let's
pick a representative example form, and figure out what its expansion
should be.  Here is a typical 3dolist* form.

.lisp
(dolist (element (append a b))
  (push element *big-list*)
  (foo element 3))
.end_lisp

We want to create a 3do* form that does the thing that the above
3dolist* form says to do.  That is the basic goal of the macro: it
must expand into code that does the same thing that the original code
says to do, but it should be in terms of existing Lisp constructs.
The 3do* form might look like this:

.lisp
(do ((list (append a b) (cdr list))
     (element))
    ((null list))
  (setq element (car list))
  (push element *big-list*)
  (foo element 3))
.end_lisp

Now we could start writing the macro that would generate this code, and
in general convert any 3dolist* into a 3do*, in an analogous way.
However, there is a problem with the above scheme for expanding the
3dolist*.  The above expansion works fine.  But what if the input
form had been the following:

.lisp
(dolist (list (append a b))
  (push list *big-list*)
  (foo list 3))
.end_lisp

This is just like the form we saw above, except that the user happened
to decide to name the looping variable 3list* rather than
3element*.  The corresponding expansion would be:

.lisp
(do ((list (append a b) (cdr list))
     (list))
    ((null list))
  (setq list (car list))
  (push list *big-list*)
  (foo list 3))
.end_lisp

This doesn't work at all!  In fact, this is not even a valid program,
since it contains a 3do* that uses the same variable in two different
iteration clauses.

Here's another example that causes trouble:

.lisp
(let ((list nil))
  (dolist (element (append a b))
    (push element list)
    (foo list 3)))
.end_lisp

If you work out the expansion of this form, you will see that there are
two variables named 3list*, and that the user meant to refer to the
outer one but the generated code for the 3push* actually uses
the inner one.

The problem here is an accidental name conflict.  This can happen in
any macro that has to create a new variable.  If that variable ever
appears in a context in which user code might access it, then you have
to worry that it might conflict with some other name that the user is
using for his own program.

One way to avoid this problem is to choose a name that is very
unlikely to be picked by the user, simply by choosing an unusual name.
This will probably work, but it is inelegant since there is no
guarantee that the user won't just happen to choose the same name.  The
way to really avoid the name conflict is to use an uninterned symbol as
the variable in the generated code.  The function 3gensym* (see
(gensym-fun)) is useful for creating such symbols.

Here is the expansion of the original form, using an uninterned
symbol created by 3gensym*.

.lisp
(do ((g0005 (append a b) (cdr g0005))
     (element))
    ((null g0005))
  (setq element (car g0005))
  (push element *big-list*)
  (foo element 3))
.end_lisp

This is the right kind of thing to expand into.  Now that we understand
how the expansion works, we are ready to actually write the macro.
Here it is:

.lisp
(defmacro dolist ((var form) . body)
  (let ((dummy (gensym)))
    `(do ((,dummy ,form (cdr ,dummy))
	  (,var))
	 ((null ,dummy))
       (setq ,var (car ,dummy))
       . ,body)))
.end_lisp

.cindex dot, in symbols
.cindex period, in symbols
Many system macros do not use 3gensym* for the internal variables in their
expansions.  Instead they use symbols whose print names begin and end with a dot.
This provides meaningful names for these variables when looking at the generated
code and when looking at the state of a computation in the error-handler.
However, this convention means that users should avoid naming variables this way.

.subsection prog-context Conflicts

A related problem occurs when you write a macro that expands into a
3prog* (or a 3do*, or something that expands into 3prog* or 3do*)
behind the user's back (unlike 3dolist*, which is documented to be like
3do*).
Consider the 3error-restart* special form (see (error-restart-fun));
suppose we wanted to implement it as a macro that expands into a 3prog*.
If it expanded into a plain-old 3prog*, then the following (contrived)
Lisp program would not behave correctly:

.lisp
(prog ()
   (setq a 3)
   (error-restart
     (cond ((> a 10)
            (return 5))
	   ((> a 4)
            (cerror nil t 'lose "You lose."))))
   (setq b 7))
.end_lisp

The problem is that the 3return* would return from the
3error-restart* instead of the 3prog*.  The way to avoid this
problem is to use a named 3prog* whose name is 3t*.  The name 3t*
is special in that it is invisible to the 3return* function.  If we
write 3error-restart* as a macro that expands into a 3prog* named
3t*, then the 3return* will pass right through the
3error-restart* form and return from the 3prog*, as it ought to.

In general, when a macro expands into a 3prog* or a 3do* around the
user's code, the 3prog* or 3do* should be named 3t* so that
3return* forms in the user code will return to the right place,
unless the macro is documented as generating a 3prog/do*-like form
which may be exited with 3return*.

.subsection Macros Expanding into Many Forms
.setq progn-quote-compile-discussion section-page
.setq progn-quote-compile-page page

Sometimes a macro wants to do several different things when its expansion
is evaluated.  Another way to say this is that sometimes a macro wants to
expand into several things, all of which should happen sequentially at run
time (not macro-expand time).  For example, suppose you wanted to implement
3defconst* (see (defconst-fun)) as a macro.  3defconst* must do two
things: declare the variable to be special, and set the variable to its
initial value.  (We will implement a simplified 3defconst* that only does
these two things, and doesn't have any options.)  What should a
3defconst* form expand into?  Well, what we would like is for an
appearance of
.lisp
(defconst a (+ 4 b))
.end_lisp
in a file to be the same thing as the appearance of the following two forms:
.lisp
(declare (special a))
(setq a (+ 4 b))
.end_lisp
However, because of the way that macros work, they only expand into one
form, not two.  So we need to have a 3defconst* form expand into
one form that is just like having two forms in the file.

There is such a form.  It looks like this:
.lisp
(progn 'compile
       (declare (special a))
       (setq a (+ 4 b)))
.end_lisp
In interpreted Lisp, it is easy to see what happens here.  This is a
3progn* special form, and so all its subforms are evaluated, in turn.
First the form 3'compile* is evaluated.  The result is the symbol
3compile*; this value is not used, and evaluation of 3'compile* has
no side-effects, so the 3'compile* subform is effectively ignored.
Then the 3declare* form and the 3setq* form are evaluated, and so
each of them happens, in turn.  So far, so good.

The interesting thing is the way this form is treated by the compiler.
The compiler specially recognizes any 3progn* form at top level in a
file whose first subform is 3'compile*.  When it sees such a
form, it processes each of the remaining subforms of the 3progn* just
as if that form had appeared at top level in the file.  So the compiler
behaves exactly as if it had encountered the 3declare* form at top
level, and then encountered the 3setq* form at top level, even though
neither of those forms was actually at top-level (they were both inside
the 3progn*).  This feature of the compiler is provided specifically for
the benefit of macros that want to expand into several things.

Here is the macro definition:
.lisp
(defmacro defconst (variable init-form)
  `(progn 'compile
	  (declare (special ,variable))
	  (setq ,variable ,init-form)))
.end_lisp

Here is another example of a form that wants to expand into several
things.  We will implement a special form called 3define-command*,
which is intended to be used in order to define commands in some
interactive user subsystem.  For each command, there are two things
provided by the 3define-command* form: a function that executes the
command, and a text string that contains the documentation for the
command (in order to provide an on-line interactive documentation
feature).  This macro is a simplified version of a macro that is
actually used in the Zwei editor.  Suppose that in
this subsystem, commands are always functions of no arguments,
documentation strings are placed on the 3help* property of the name
of the command, and the names of all commands are put onto a list.
A typical call to 3define-command* would look like:
.lisp
(define-command move-to-top
   "This command moves you to the top."
   (do ()
       ((at-the-top-p))
     (move-up-one)))
.end_lisp
This could expand into:
.lisp
(progn 'compile
       (defprop
	 move-to-top
	 "This command moves you to the top."
	 help)
       (push 'move-to-top *command-name-list*)
       (defun move-to-top ()
	 (do ()
	     ((at-the-top-p))
	   (move-up-one)))
       )
.end_lisp
The 3define-command* expands into three forms.  The first one sets up
the documentation string and the second one puts the command name onto
the list of all command names.  The third one is the 3defun* that
actually defines the function itself.  Note that the 3defprop* and
3push* happen at load-time (when the file is loaded); the function,
of course, also gets defined at load time.  (See the description of
3eval-when* ((eval-when-fun)) for more discussion of the differences
between compile time, load time, and eval time.)

This technique makes Lisp a powerful language in which to implement
your own language.  When you write a large system in Lisp, frequently
you can make things much more convenient and clear by using macros to
extend Lisp into a customized language for your application.  In the
above example, we have created a little language extension: a new
special form that defines commands for our system.  It lets the writer
of the system put his documentation strings right next to the code that
they document, so that the two can be updated and maintained together.
The way that the Lisp environment works, with load-time evaluation able
to build data structures, lets the documentation data base and the list
of commands be constructed automatically.

.subsection Macros that Surround Code

There is a particular kind of macro that is very useful for many
applications.  This is a macro that you place "around" some Lisp code,
in order to make the evaluation of that code happen in some context.
For a very simple example, we could define a macro called
3with-output-in-base*, that executes the forms within its body
with any output of numbers that is done defaulting to a specified base.
.lisp
(defmacro with-output-in-base ((base-form) &body body)
   `(let ((base ,base-form))
      . ,body))
.end_lisp
A typical use of this macro might look like:
.lisp
(with-output-in-base (*default-base*)
   (print x)
   (print y))
.end_lisp
which would expand into
.lisp
(let ((base *default-base*))
  (print x)
  (print y))
.end_lisp

This example is too trivial to be very useful; it is intended to
demonstrate some stylistic issues.  There are some special forms in
Zetalisp that are similar to this macro; see
3with-open-file* ((with-open-file-fun)) and 3with-input-from-string*
((with-input-from-string-fun)), for example.
The really interesting thing, of course, is that you can define your
own such special forms for your own specialized applications.  One very
powerful application of this technique was used in a system that
manipulates and solves the Rubik's cube puzzle.  The system heavily
uses a special form called 3with-front-and-top*, whose meaning is
"evaluate this code in a context in which this specified face of the
cube is considered the front face, and this other specified face is
considered the top face".

The first thing to keep in mind when you write this sort of macro is
that you can make your macro much clearer to people who might read your
program if you conform to a set of loose standards of syntactic style.
By convention, the names of such special forms start with "3with-*".
This seems to be a clear way of expressing the concept that we are
setting up a context; the meaning of the special form is "do this stuff
2with* the following things true".  Another convention is that any
"parameters" to the special form should appear in a list that is the
first subform of the special form, and that the rest of the subforms
should make up a body of forms that are evaluated sequentially with the
last one returned.  All of the examples cited above work this way.  In
our 3with-output-in-base* example, there was one parameter (the
base), which appears as the first (and only) element of a list that is
the first subform of the special form.  The extra level of parentheses
in the printed representation serves to separate the "parameter" forms
from the "body" forms so that it is textually apparent which is which;
it also provides a convenient way to provide default parameters (a good
example is the 3with-input-from-string* special form
((with-input-from-string-fun)), which takes two required and two
optional "parameters").  Another convention/technique is to use the
3&body* keyword in the 3defmacro* to tell the editor how to
correctly indent the special form (see (&body)).

The other thing to keep in mind is that control can leave the special
form either by the last form's returning, or by a non-local exit (that
is, something doing a 3*throw*).  You should write the special form
in such a way that everything will be cleaned up appropriately no
matter which way control exits.  In our 3with-output-in-base*
example, there is no problem, because non-local exits undo
lambda-bindings.  However, in even slightly more complicated cases, an
3unwind-protect* form (see (unwind-protect-fun)) is needed: the
macro must expand into an 3unwind-protect* that surrounds the body,
with "cleanup" forms that undo the context-setting-up that the macro
did.  For example, 3using-resource* (see (using-resource-fun))
is implemented as a macro
that does an 3allocate-resource* and then performs the body inside of
an 3unwind-protect* that has a 3deallocate-resource* in its
"cleanup" forms.  This way the allocated resource item will be
deallocated whenever control leaves the 3using-resource* special form.

.subsection Multiple and Out-of-order Evaluation

In any macro, you should always pay attention to the problem of
multiple or out-of-order evaluation of user subforms.  Here is an
example of a macro with such a problem.  This macro defines a special
form with two subforms.  The first is a reference, and the second is a
form.  The special form is defined to create a cons whose car and cdr
are both the value of the second subform, and then to set the reference
to be that cons.  Here is a possible definition:
.lisp
(defmacro test (reference form)
   `(setf ,reference (cons ,form ,form)))
.end_lisp
Simple cases will work all right:
.lisp
(test foo 3) ==>
  (setf foo (cons 3 3))
.end_lisp
But a more complex example, in which the subform has side effects,
can produce surprising results:
.lisp
(test foo (setq x (1+ x))) ==>
  (setf foo (cons (setq x (1+ x))
                  (setq x (1+ x))))
.end_lisp
The resulting code evaluates the 3setq* form twice, and so 3x*
is increased by two instead of by one.  A better definition of 3test*
that avoids this problem is:
.lisp
(defmacro test (reference form)
   (let ((value (gensym)))
     `(let ((,value ,form))
         (setf ,reference (cons ,value ,value)))))
.end_lisp
With this definition, the expansion works as follows:
.lisp
(test foo (setq x (1+ x))) ==>
  (let ((g0005 (setq x (1+ x))))
     (setf foo (cons g0005 g0005)))
.end_lisp

In general, when you define a new special form that has some forms as
its subforms, you have to be careful about just when those forms get
evaluated.  If you aren't careful, they can get evaluated more than
once, or in an unexpected order, and this can be semantically
significant if the forms have side-effects.  There's nothing
fundamentally wrong with multiple or out-of-order evalation if that is
really what you want and if it is what you document your special form
to do.  However, it is very common for special forms to simply behave
like functions, and when they are doing things like what functions do,
it's natural to expect them to be function-like in the evaluation of
their subforms.  Function forms have their subforms evaluated, each
only once, in left-to-right order, and special forms that are similar
to function forms should try to work that way too for clarity and
consistency.

There is a tool that makes it easier for you to follow the principle
explained above.  It is a macro called 3once-only*.  It is most easily
explained by example.  The way you would write 3test* using
3once-only* is as follows:
.lisp
(defmacro test (reference form)
  (once-only (form)
    `(setf ,reference (cons ,form ,form))))
.end_lisp
This defines 3test* in such a way that the 3form* is only evaluated
once, and references to 3form* inside the macro body refer to that
value.  3once-only* automatically introduces a lambda-binding of a
generated symbol to hold the value of the form.  Actually, it is more
clever than that; it avoids introducing the lambda-binding for forms
whose evaluation is trivial and may be repeated without harm nor cost,
such as numbers, symbols, and quoted structure.  This is just an
optimization that helps produce more efficient code.

The 3once-only* macro makes it easier to follow the principle, but it
does not completely nor automatically solve the problems of multiple and
out-of-order evaluation.  It is just a tool that can solve some of the
problems some of the time; it is not a panacea.

The following description attempts to explain what 3once-only* does,
but it is a lot easier to use 3once-only* by imitating the example
above than by trying to understand 3once-only*'s rather tricky
definition.

.defmac once-only
A 3once-only* form looks like 
.lisp
(once-only 2var-list*
  2form1*
  2form2*
  ...)
.end_lisp
2var-list* is a list of variables.  The 2forms* are a Lisp program,
that presumably uses the values of those variables.  When the form
resulting from the expansion of the 3once-only* is evaluated, the first
thing it does is to inspect the values of each of the variables in
2var-list*; these values are assumed to be Lisp forms.  For each of the
variables, it binds that variable either to its current value, if the
current value is a trivial form, or to a generated symbol.  Next,
3once-only* evaluates the 2forms*, in this new binding environment, and
when they have been evaluated it undoes the bindings.  The result of the
evaluation of the last 2form* is presumed to be a Lisp form, typically
the expansion of a macro.  If all of the variables had been bound to
trivial forms, then 2once-only* just returns that result.  Otherwise,
3once-only* returns the result wrapped in a lambda-combination that binds
the generated symbols to the result of evaluating the respective
non-trivial forms.

The effect is that the program produced by evaluating the 3once-only* form
is coded in such a way that it only evaluates each form once, unless evaluation
of the form has no side-effects, for each of the forms which were the values
of variables in 2var-list*.  At the same time, no unnecessary 3lambda*-binding
appears in this program, but the body of the 3once-only* is not cluttered up
with extraneous code to decide whether or not to introduce 3lambda*-binding
in the program it constructs.
.end_defmac

Caution!  A number of system macros, 3setf* for example, fail to
follow this convention.  Unexpected multiple evaluation and out-of-order
evaluation can occur with them.  This was done for the sake of efficiency,
is prominently mentioned in the documentation of these macros, and will
be fixed in the future.  It would be best not to compromise the semantic
simplicity of your own macros in this way.

.subsection Nesting Macros
.setq compiler-let-discussion section-page

A useful technique for building language extensions is to define
programming constructs that employ two special forms, one of which is
used inside the body of the other.  Here is a simple example.  There
are two special forms.  The outer one is called 3with-collection*,
and the inner one is called 3collect*.  3collect* takes one
subform, which it evaluates; 3with-collection* just has a body, whose
forms it evaluates sequentially.  3with-collection* returns a list of
all of the values that were given to 3collect* during the evaluation
of the 3with-collection*'s body.  For example,
.lisp
(with-collection
  (dotimes (i 5)
    (collect i)))

  => (1 2 3 4 5)
.end_lisp
Remembering the first piece of advice we gave about macros, the
next thing to do is to figure out what the expansion looks like.
Here is how the above example could expand:
.lisp
(let ((g0005 nil))
  (dotimes (i 5)
     (push i g0005))
  (nreverse g0005))
.end_lisp
Now, how do we write the definition of the macros?  Well,
3with-collection* is pretty easy:
.lisp
(defmacro with-collection (&body body)
  (let ((var (gensym)))
     `(let ((,var nil))
        ,@body
        (nreverse ,var))))
.end_lisp
The hard part is writing 3collect*.  Let's try it:
.lisp
(defmacro collect (argument)
  `(push ,argument ,var))
.end_lisp
Note that something unusual is going on here: 3collect* is using the
variable 3var* freely.  It is depending on the binding that takes
place in the body of 3with-collection* in order to get access to the
value of 3var*.  Unfortunately, that binding took place when
3with-collection* got expanded; 3with-collection*'s expander
function bound 3var*, and it got unbound when the expander function
was done.  By the time the 3collect* form gets expanded, 3var* has
long since been unbound.  The macro definitions above do not work.
Somehow the expander function of 3with-collection* has to communicate
with the expander function of 3collect* to pass over the generated
symbol.

The only way for 3with-collection* to convey information to the
expander function of 3collect* is for it to expand into something
that passes that information.  What we can do is to define a special
variable (which we will call 3*collect-variable**), and have
3with-collection* expand into a form that binds this variable to the
name of the variable that the 3collect* should use.  Now, consider
how this works in the interpreter.  The evaluator will first see the
3with-collection* form, and call in the expander function to expand
it.  The expander function creates the expansion, and returns to the
evaluator, which then evaluates the expansion.  The expansion includes
in it a 3let* form to bind 3*collect-variable** to the generated
symbol.  When the evaluator ses this 3let* form during the evaluation
of the expansion of the 3with-collection* form, it will set up the
binding and recursively evaluate the body of the 3let*.  Now, during
the evaluation of the body of the 3let*, our special variable is
bound, and if the expander function of 3collect* gets run, it will be
able to see the value of 3collection-variable* and incorporate the
generated symbol into its own expansion.

Writing the macros this way is not quite right.  It works fine
interpreted, but the problem is that it does not work when we try to
compile Lisp code that uses these special forms.  When code is being
compiled, there isn't any interpreter to do the binding in our new
3let* form; macro expansion is done at compile time, but generated
code does not get run until the results of the compilation are loaded
and run.  The way to fix our definitions is to use 3compiler-let*
instead of 3let*.  3compiler-let* (see (compiler-let-fun)) is a
special form that exists specifically to do the sort of thing we are
trying to do here.  3compiler-let* is identical to 3let* as far as
the interpreter is concerned, so changing our 3let* to a
3compiler-let* won't affect the behavior in the interpreter; it will
continue to work.  When the compiler encounters a 3compiler-let*, however,
it actually performs the bindings that the 3compiler-let* specifies,
and proceeds to compile the body of the 3compiler-let* with all of
those bindings in effect.  In other words, it acts as the interpreter
would.

Here's the right way to write these macros:
.lisp
(defvar *collect-variable*)

(defmacro with-collection (&body body)
  (let ((var (gensym)))
     `(let ((,var nil))
        (compiler-let ((*collect-variable* ',var))
           . ,body)
        (nreverse ,var))))

(defmacro collect (argument)
  `(push ,argument ,*collect-variable*))
.end_lisp

.subsection Functions Used During Expansion

The technique of defining functions to be used during macro expansion
deserves explicit mention here.  It may not occur to you, but a macro
expander function is a Lisp program like any other Lisp program, and it
can benefit in all the usual ways by being broken down into a
collection of functions that do various parts of its work.  Usually
macro expander functions are pretty simple Lisp programs that take
things apart and put them together slightly differently and such, but
some macros are quite complex and do a lot of work.  Several features
of Zetalisp, including flavors, 3loop*, and 3defstruct*,
are implemented using very complex macros, which, like any complex
well-written Lisp program, are broken down into modular functions.  You should
keep this in mind if you ever invent an advanced language extension
or ever find yourself writing a five-page expander function.

A particular thing to note is that any functions used by macro-expander
functions must be available at compile-time.  You can make a function
available at compile time by surrounding its defining form with an
3(eval-when (compile load eval) ...)*; see (eval-when-fun) for more
details.  Doing this means that at compile time the definition of the
function will be interpreted, not compiled, and hence will run more
slowly.  Another approach is to separate macro definitions and the
functions they call during expansion into a separate file, often called
a "defs" (definitions) file.  This file defines all the macros but does
not use any of them.  It can be separately compiled and loaded up
before compiling the main part of the program, which uses the macros.
The 2system* facility (see (system-system)) helps keep these
various files straight, compiling and loading things in the right order.


.section "Aids for Debugging Macros"

.defun mexp
3mexp* goes into a loop in which it reads forms and sequentially
expands them, printing out the result of each expansion (using
the grinder (see (grind)) to improve readability).  It terminates
when it reads an atom (anything that is not a cons).  If you type
in a form which is not a macro form, there will be no expansions
and so it will not type anything out, but just prompt you for
another form.  This allows you to see what your macros are
expanding into, without actually evaluating the result of the expansion.
.end_defun

.section "Displacing Macros"
.setq displacing-macro section-page
.cindex displacing macros
	Every time the the evaluator sees a macro form, it must
call the macro to expand the form.  If this expansion always
happens the same way, then it is wasteful to expand the whole
form every time it is reached; why not just expand it once?
A macro is passed the macro form itself, and so it can change
the car and cdr of the form to something else by using 3rplaca*
and 3rplacd*!  This way the first time the macro is expanded,
the expansion will be put where the macro form used to be, and the
next time that form is seen, it will already be expanded.  A macro that
does this is called a 2displacing macro*, since it displaces
the macro form with its expansion.

	The major problem with this is that the Lisp form
gets changed by its evaluation.  If you were to write a program
which used such a macro, call 3grindef* to look at it,
then run the program and call 3grindef* again, you would
see the expanded macro the second time.  Presumably the reason
the macro is there at all is that it makes the program look nicer;
we would like to prevent the unnecessary expansions, but still let
3grindef* display the program in its more attractive form.
This is done with the function 3displace*.

	Anothing thing to worry about with displacing macros is that if
you change the definition of a displacing macro, then your new
definition will not take effect in any form that has already been
displaced.  If you redefine a displacing macro, an existing form using
the macro will use the new definition only if the form has never been
evaluated.

.defun displace form expansion
2form* must be a list.
3displace* replaces the car and cdr of 2form* so
that it looks like:
.lisp
(si:displaced 2original-form* 2expansion*)
.end_lisp
2original-form* is equal to 2form* but has a different
top-level cons so that the replacing mentioned above doesn't
affect it.  3si:displaced* is a macro, which returns
the caddr of its own macro form.  So when the 3si:displaced*
form is given to the evaluator, it "expands" to 2expansion*.
3displace* returns 2expansion*.
.end_defun

	The grinder knows specially about 3si:displaced* forms,
and will grind such a form as if it had seen the original-form
instead of the 3si:displaced* form.

	So if we wanted to rewrite our 3addone* macro as a displacing
macro, instead of writing
.lisp
(macro addone (x)
   (list 'plus '1 (cadr x)))
.end_lisp
we would write
.lisp
(macro addone (x)
   (displace x (list 'plus '1 (cadr x))))
.end_lisp

	Of course, we really want to use 3defmacro* to define
most macros.  Since there is no way to get at the original macro form itself
from inside the body of a 3defmacro*, another version of it is
provided:

.defmac defmacro-displace
3defmacro-displace* is just like 3defmacro* except that
it defines a displacing macro, using the 3displace* function.
.end_defmac

	Now we can write the displacing version of 3addone* as
.lisp
(defmacro-displace addone (val)
   (list 'plus '1 val))
.end_lisp
All we have changed in this example is the 3defmacro* into
3defmacro-displace*.  3addone* is now a displacing macro.

.section "Advanced Features of Defmacro"
.setq defmacro-hair section-page

The pattern in a 3defmacro* is more like the 3lambda*-list
of a normal function than revealed above.  It is allowed to
contain certain 3&*-keywords.

3&optional* is followed by 2variable*, 3(2variable*)*,
3(2variable* 2default*)*, or 3(2variable* 2default*
2present-p*)*, exactly the same as in a function.  Note that
2default* is still a form to be evaluated, even though 2variable*
is not being bound to the value of a form.  2variable* does not have
to be a symbol; it can be a pattern.  In this case the first form is
disallowed because it is syntactically ambigous.  The pattern must be
enclosed in a singleton list.  If 2variable* is a pattern, 2default*
can be evaluated more than once.

Using 3&rest* is the same as using a dotted list as the pattern,
except that it may be easier to read and leaves a place to put 3&aux*.

3&aux* is the same in a macro as in a function, and has nothing to do
with pattern matching.

3defmacro* has a couple of additional keywords not allowed in functions.

.setq &body page
3&body* is identical to 3&rest* except that it informs the editor and the grinder
that the remaining subforms constitute a "body" rather than "arguments"
and should be indented accordingly.

.setq &list-of page
3&list-of* 2pattern* requires the corresponding position of the
form being translated to contain a list (or 3nil*).  It
matches 2pattern* against each element of that list.  Each variable
in 2pattern* is bound to a list of the corresponding values in each element
of the list matched by the 3&list-of*.  This may be clarified by an
example.  Suppose we want to be able to say things like
.lisp
(send-commands (aref turtle-table i)
  (forward 100)
  (beep)
  (left 90)
  (pen 'down 'red)
  (forward 50)
  (pen 'up))
.end_lisp
We could define a 3send-commands* macro as follows:
.lisp
(defmacro send-commands (object
		&body &list-of (command . arguments))
  `(let ((o ,object))
     . ,(mapcar #'(lambda (com args) `(send o ',com . ,args))
		command arguments)))
.end_lisp
Note that this example uses 3&body* together with 3&list-of*, so you
don't see the list itself; the list is just the rest of the macro-form.

You can combine 3&optional* and 3&list-of*.  Consider the following example:
.lisp
(defmacro print-let (x &optional &list-of ((vars vals)
					   '((base 10.)
					     (*nopoint t))))
  `((lambda (,@vars) (print ,x))
    ,@vals))

(print-let foo)  ==>
((lambda (base *nopoint) 
   (print foo))
 12
 t)

(print-let foo ((bar 3)))  ==>
((lambda (bar)
   (print foo))
 3)
.end_lisp
In this example we aren't using 3&body* or anything like it, so you do see
the list itself; that is why you see parentheses around the 3(bar 3)*.

.section "Functions to Expand Macros"

	The following two functions are provided to allow the user to
control expansion of macros; they are often useful for the writer of
advanced macro systems, and in tools that want to examine and understand
code which may contain macros.

.defun macroexpand-1 form
If 2form* is a macro form, this expands it (once)
and returns the expanded form.  Otherwise it just
returns 2form*.  3macroexpand-1* expands 3defsubst*
function forms as well as macro forms.
.end_defun

.defun macroexpand form
If 2form* is a macro form, this expands it repeatedly
until it is not a macro form, and returns the final expansion.
Otherwise, it just returns 2form*.  3macroexpand* expands 3defsubst*
function forms as well as macro forms.
.end_defun

.section Generalized Variables
.cindex setf

In Lisp, a variable is something that can remember one piece of data.  The
main operations on a variable are to recover that piece of data, and to
change it.  These might be called 2access* and 2update*.  The concept of
variables named by symbols, explained in (variable-section), can be
generalized to any storage location that can remember one piece of data, no
matter how that location is named.

For each kind of generalized variable, there are typically two functions
which implement the conceptual 2access* and 2update* operations.  For
example, 3symeval* accesses a symbol's value cell, and 3set* updates
it.  3array-leader* accesses the contents of an array leader element, and
3store-array-leader* updates it.  3car* accesses the car of a cons,
and 3rplaca* updates it.

Rather than thinking of this as two functions, which operate on a storage
location somehow deduced from their arguments, we can shift our point of
view and think of the access function as a 2name* for the storage
location.  Thus 3(symeval 'foo)* is a name for the value of 3foo*, and
3(aref a 105)* is a name for the 105th element of the array 3a*.
Rather than having to remember the update function associated with each
access function, we adopt a uniform way of updating storage locations named
in this way, using the 3setf* special form.  This is analogous to the
way we use the 3setq* special form to convert the name of a variable
(which is also a form which accesses it) into a form which updates it.

3setf* is particularly useful in combination with structure-accessing
macros, such as those created with 3defstruct*, because the knowledge of the
representation of the structure is embedded inside the macro, and the programmer
shouldn't have to know what it is in order to alter an element of the structure.

3setf* is actually a macro which expands into the appropriate update function.
It has a database, explained below, which associates from access functions to
update functions.

.defmac setf access-form value
3setf* takes a form which 2accesses* something, and "inverts"
it to produce a corresponding form to 2update* the thing.
A 3setf* expands into an update form, which stores the result of evaluating
the form 2value* into the place referenced by the 2access-form*.
.lisp
.exdent 96 Examples:
(setf (array-leader foo 3) 'bar)
		==> (store-array-leader 'bar foo 3)
(setf a 3) ==> (setq a 3)
(setf (plist 'a) '(foo bar)) ==> (setplist 'a '(foo bar))
(setf (aref q 2) 56) ==> (aset 56 q 2)
(setf (cadr w) x) ==> (rplaca (cdr w) x)
.end_lisp

If 2access-form* invokes a macro or a substitutable function, then
3setf* expands the 2access-form* and starts over again.  This lets you
use 3setf* together with 3defstruct* accessor macros.

For the sake of efficiency, the code produced by 3setf*
does not preserve order of evaluation of the argument forms.  This is only a problem
if the argument forms have interacting side-effects.  For example,
if you evaluate
.lisp
(setq x 3)
(setf (aref a x) (setq x 4))
.end_lisp
then the form might set element 33* or element 34* of the array.
We do not guarantee which one it will do; don't just try it and see
and then depend on it, because it is subject to change without notice.

Furthermore, the value produced by 3setf* depends on the structure
type and is not guaranteed; 3setf* should be used for side effect
only.
.end_defmac

Besides the 2access* and 2update* conceptual operations on variables, there
is a third basic operation, which we might call 2locate*.  Given the name of
a storage cell, the 2locate* operation will return the address of that cell
as a locative pointer (see (locative)).  This locative pointer is a kind of
name for the variable which is a first-class Lisp data object.  It can be
passed as an argument to a function which operates on any kind of variable,
regardless of how it is named.  It can be used to 2bind* the variable, using
the 3bind* subprimitive (see (bind-fun)).

Of course this can only work on variables whose implementation is really to
store their value in a memory cell.  A variable with an 2update*
operation that encrypts the value and an 2access* operation that decrypts
it could not have the 2locate* operation, since the value per se is not
actually stored anywhere.

.defmac locf access-form
3locf* takes a form which 2accesses* some cell, and produces
a corresponding form to create a locative pointer to that cell.
.lisp
.exdent 96 Examples:
(locf (array-leader foo 3)) ==> (ap-leader foo 3)
(locf a) ==> (value-cell-location 'a)
(locf (plist 'a)) ==> (property-cell-location 'a)
(locf (aref q 2)) ==> (aloc q 2)
.end_lisp

If 2access-form* invokes a macro or a substitutable function, then
3locf* expands the 2access-form* and starts over again.  This lets you
use 3locf* together with 3defstruct* accessor macros.
.end_defmac

	Both 3setf* and 3locf* work by means of property lists.
When the form 3(setf (aref q 2) 56)* is expanded, 3setf* looks
for the 3setf* property of the symbol 3aref*.  The value of the
3setf* property of a symbol should be a cons whose car
is a pattern to be matched with the 2access-form*, and whose 3cdr*
is the corresponding 2update-form*, with the symbol 3si:val* in
place of the value to be stored.  The 3setf* property of 3aref*
is a cons whose car is 3(aref array . subscripts)* and whose
cdr is 3(aset si:val array . subscripts)*.  If the transformation which
3setf* is to do cannot be expressed as a simple pattern, an arbitrary
function may be used:  When the form 3(setf (foo bar) baz)*
is being expanded, if the 3setf* property of 3foo* is a symbol,
the function definition of that symbol will be applied to two arguments,
3(foo bar)* and 3baz*, and the result will be taken to be the
expansion of the 3setf*.

Similarly, the 3locf* function
uses the 3locf* property, whose value is analogous.  For example, the 3locf* property
of 3aref* is a cons whose car is 3(aref array . subscripts)*
and whose cdr is 3(aloc array . subscripts)*.  There is no 3si:val*
in the case of 3locf*.

.defmac incf access-form [amount]
Increments the value of a generalized variable.  3(incf 2ref*)* increments
the value of 2ref* by 1.  3(incf 2ref* 2amount*)* adds 2amount*
to 2ref* and stores the sum back into 2ref*.

3incf* expands into a 3setf* form, so 2ref* can be anything that
3setf* understands as its 2access-form*.  This also means that you
should not depend on the returned value of an 3incf* form.

You must take great care with 3incf* because it may evaluate
parts of 2ref* more than once.  For example,
.lisp
(incf (car (mumble))) ==>
(setf (car (mumble)) (1+ (car (mumble)))) ==>
(rplaca (mumble) (1+ (car (mumble))))
.end_lisp
The 3mumble* function is called more than once, which may be
significantly inefficient if 3mumble* is expensive, and which may be
downright wrong if 3mumble* has side-effects.  The same problem
can come up with the 3decf*, 3push*, and 3pop* macros (see below).
.end_defmac

.defmac decf access-form [amount]
Decrements the value of a generalized variable.  3(decf 2ref*)* decrements
the value of 2ref* by 1.  3(decf 2ref* 2amount*)* subtracts 2amount*
from 2ref* and stores the difference back into 2ref*.

3decf* expands into a 3setf* form, so 2ref* can be anything that
3setf* understands as its 2access-form*.  This also means that you
should not depend on the returned value of a 3decf* form.
.end_defmac

.defmac push item access-form
Adds an item to the front of a list which is stored in a generalized variable.
3(push 2item* 2ref*)*
creates a new cons whose car is the result of evaluating 2item*
and whose cdr is the contents of 2ref*, and stores the new cons
into 2ref*.

The form
.lisp
(push (hairy-function x y z) variable)
.end_lisp
replaces the commonly-used construct
.lisp
(setq variable (cons (hairy-function x y z) variable))
.end_lisp
and is intended to be more explicit and esthetic.

All the caveats that apply to 3incf* apply to 3push* as well:
forms within 2ref* may be evaluated more than once.  The returned value
of 3push* is not defined.
.end_defmac

.defmac pop access-form
Removes an element from the front of a list which is stored in a generalized variable.
3(pop 2ref*)* finds the cons in 2ref*, stores the cdr of the cons back into 2ref*,
and returns the car of the cons.
.lisp
.exdent 96 Example:
(setq x '(a b c))
(pop x) => a
x => (b c)
.end_lisp
All the caveats that apply to 3incf* apply to 3pop* as well:
forms within 2ref* may be evaluated more than once.
.end_defmac
